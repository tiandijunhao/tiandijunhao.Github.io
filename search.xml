<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>晶体的单晶声速</title>
      <link href="/2020/05/05/jing-ti-de-dan-jing-sheng-su-ji-suan-gong-shi/"/>
      <url>/2020/05/05/jing-ti-de-dan-jing-sheng-su-ji-suan-gong-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="晶体的单晶声速计算公式"><a href="#晶体的单晶声速计算公式" class="headerlink" title="晶体的单晶声速计算公式"></a><strong>晶体的单晶声速计算公式</strong></h1><p>Christoffel’s equation relates acoustic velocitics to crystallo-graphic direction and elastic constants.</p><script type="math/tex; mode=display">det|C_{ijkl}n_{l}n_{j}-\rho v^{2}\delta_{ik}|=0 \\det|F_{ik}n_{l}n_{j}-\rho v^{2}\delta_{ik}|=0 \\i,j,k,l=1,2,3; \\when\ i=k; then\ \delta=1; others\ \delta=0</script><p>So, the Kelvin-Christoffel stiffness $\Gamma_{ik}$ is:</p><script type="math/tex; mode=display">\Gamma_{ik}=\sum_{j,l=1}^{n=3} C_{ijkl}n_{j}n_{l},\ i,k=1,2,3 \\\Gamma = \begin{bmatrix} \Gamma_{11} & \Gamma_{12} & \Gamma_{13} \\ \Gamma_{12} & \Gamma_{22} & \Gamma_{23} \\ \Gamma_{13} & \Gamma_{23} & \Gamma_{33}\end{bmatrix}</script><p>For $n_{j}(\phi,\theta,\chi),n_{l}(\phi,\theta,\chi)$ :</p><script type="math/tex; mode=display">n_1=cos(\phi)cos(\theta)cos(\chi)-sin(\phi)sin(\chi) \\n_2=-cos(\phi)cos(\theta)sin(\chi)-sin(\phi)cos(\chi) \\n_3=-cos(\phi)sin(\theta)</script><p>then, we can calculate the eigenvalues of matrix equation ($\lambda_i,i=1,2,3$).</p><script type="math/tex; mode=display">\lambda_1=\rho v_l^2 \\\lambda_2=\rho v_{s1}^2 \\\lambda_3=\rho v_{s2}^2</script><p>Reference:</p><p>Sound velocity and elasticity of single-crystal forsterite to 16 GPa; DOI: 10.1029/96JB01266</p><hr><p>The fortran code:</p><pre class=" language-lang-fortran"><code class="language-lang-fortran">module singal_sound_velocity    contains    subroutine sing_sound_velocity(Celas, theta, phi, chi,  V_sing)            ! Celas: elastic constants            implicit none            real(kind=8) :: theta, phi ,chi, Celas(6,6)            real(kind=8) :: V_sing(3,3)            real(kind=8) :: n1,n2,n3            real(kind=8) :: f(3,3), Fv(3,3),E(3,3), namda(3,3)            integer :: n=3             real(kind=8) :: err            integer :: i,j            n1=cosd(theta)*cosd(phi)*cosd(chi)-sind(phi)*sind(chi)            n2=-cosd(theta)*cosd(phi)*sind(chi)-sind(phi)*cosd(chi)            n3=sind(theta)*cosd(phi)            f(1,1)=n1*n1*Celas(1,1)+n1*n2*Celas(1,6)+n1*n3*Celas(1,5) &                  +n2*n1*Celas(6,1)+n2*n2*Celas(6,6)+n2*n3*Celas(6,5) &                  +n3*n1*Celas(5,1)+n3*n2*Celas(5,6)+n3*n3*Celas(5,5)            f(2,2)=n1*n1*Celas(6,6)+n1*n2*Celas(6,2)+n1*n3*Celas(6,4) &                  +n2*n1*Celas(2,6)+n2*n2*Celas(2,2)+n2*n3*Celas(2,4) &                  +n3*n1*Celas(4,6)+n3*n2*Celas(4,2)+n3*n3*Celas(4,4)            f(3,3)=n1*n1*Celas(5,5)+n1*n2*Celas(5,4)+n1*n3*Celas(5,3) &                  +n2*n1*Celas(4,5)+n2*n2*Celas(4,4)+n2*n3*Celas(4,3) &                  +n3*n1*Celas(3,5)+n3*n2*Celas(3,4)+n3*n3*Celas(3,3)            f(1,2)=n1*n1*Celas(1,6)+n1*n2*Celas(1,2)+n1*n3*Celas(1,4) &                  +n2*n1*Celas(6,6)+n2*n2*Celas(6,2)+n2*n3*Celas(6,4) &                  +n3*n1*Celas(5,6)+n3*n2*Celas(5,2)+n3*n3*Celas(5,4)            f(1,3)=n1*n1*Celas(1,5)+n1*n2*Celas(1,4)+n1*n3*Celas(1,3) &                  +n2*n1*Celas(6,5)+n2*n2*Celas(6,4)+n2*n3*Celas(6,3) &                  +n3*n1*Celas(5,5)+n3*n2*Celas(5,4)+n3*n3*Celas(5,3)            f(2,3)=n1*n1*Celas(6,5)+n1*n2*Celas(6,4)+n1*n3*Celas(6,3) &                  +n2*n1*Celas(2,5)+n2*n2*Celas(2,4)+n2*n3*Celas(2,3) &                  +n3*n1*Celas(4,5)+n3*n2*Celas(4,4)+n3*n3*Celas(4,3)            Fv(1,1)=f(1,1)            Fv(2,2)=f(2,2)            Fv(3,3)=f(3,3)            Fv(1,2)=f(1,2)            Fv(1,3)=f(1,3)            Fv(2,1)=f(1,2)            Fv(3,1)=f(1,3)            Fv(2,3)=f(2,3)            Fv(3,2)=f(2,3)            err=1.0d-8            call eigenvector_calc(Fv,3,namda,err)            V_sing=namda            open(unit=89,file="velocity.out")            do i=1,3               write(89,*) (namda(i,j),j=1,3)            enddo            do i=1,3               write(89,*) (Fv(i,j),j=1,3)            enddo    end subroutine sing_sound_velocity    subroutine eigenvector_calc(a,n,e,eps)        !==============================================================        ! Compute all eigenvalues: real symmetric matrix a(n,n,)        ! a*x = lambda*x         ! method: the basic QR method        ! Alex G. (January 2010)        !--------------------------------------------------------------        ! input ...        ! a(n,n) - array of coefficients for matrix A        ! n      - dimension        ! eps    - convergence tolerance        ! output ...        ! e(n)   - eigenvalues        ! iter   - number of iterations to achieve the tolerance        ! comments ...        ! kmax   - max number of allowed iterations        !==============================================================        implicit none        integer :: n ,iter        real(kind=8) :: a(n,n), e(n,n), eps        real(kind=8) :: q(n,n), r(n,n), w(n), an, Ajnorm, sum, e0,e1         integer :: k, i, j, m        integer, parameter::kmax=1000        ! initialization        q = 0.0        r = 0.0        e0 = 0.0        do k=1,kmax              ! iterations        ! step 1: compute Q(n,n) and R(n,n)        ! column 1          an = Ajnorm(a,n,1)          r(1,1) = an          do i=1,n            q(i,1) = a(i,1)/an          end do        ! columns 2,...,n          do j=2,n            w = 0.0            do m=1,j-1        ! product q^T*a result = scalar              sum = 0.0              do i=1,n                sum = sum + q(i,m)*a(i,j)              end do              r(m,j) = sum        ! product (q^T*a)*q  result = vector w(n)              do i=1,n                w(i) = w(i) + sum*q(i,m)              end do            end do        ! new a'(j)            do i =1,n              a(i,j) = a(i,j) - w(i)            end do        ! evaluate the norm for a'(j)            an = Ajnorm(a,n,j)            r(j,j) = an        ! vector q(j)            do i=1,n              q(i,j) = a(i,j)/an            end do          end do        ! step 2: compute A=R(n,n)*Q(n,n)          a = matmul(r,q)        ! egenvalues and the average eigenvale          sum = 0.0          do i=1,n            e(i,i) = a(i,i)            sum = sum+e(i,i)*e(i,i)          end do            e1 = sqrt(sum)        ! print here eigenvalues        !  write (*,201)  (e(i),i=1,n)        !201 format (6f12.6)        ! check for convergence          if (abs(e1-e0) < eps) exit        ! prepare for the next iteration          e0 = e1          end do        iter = k        if(k == kmax) write (*,*)'The eigenvlue failed to converge'    end subroutine eigenvector_calcend module</code></pre>]]></content>
      
      
      <categories>
          
          <category> VASP计算笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fortran_learn </tag>
            
            <tag> VASP </tag>
            
            <tag> 弹性常数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fortran三角方程求解</title>
      <link href="/2020/05/02/fortran-san-jiao-fang-cheng-qiu-jie/"/>
      <url>/2020/05/02/fortran-san-jiao-fang-cheng-qiu-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="Fortran-三角矩阵求解"><a href="#Fortran-三角矩阵求解" class="headerlink" title="Fortran 三角矩阵求解"></a><strong>Fortran 三角矩阵求解</strong></h2><p>参考：《Fotran95 2003科学计算与工程》</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h3><script type="math/tex; mode=display">\vec{A}(n,n)\cdot\vec{X}(n)=\vec{B}</script><p>上三角形方程迭代求解</p><script type="math/tex; mode=display">\begin{cases}    X_n=\frac{B_n}{A_{nn}} \\    \\    X_i=\frac{B_i-\sum_{k=i+1}^{n} A_{ik}X_k}{A_{ii}},i=n-1,\cdot\cdot\cdot,1\end{cases}</script><p>下三角形方程迭代求解</p><script type="math/tex; mode=display">\begin{cases}    X_1=\frac{B_1}{A_{11}} \\    \\    X_i=\frac{B_i-\sum_{k=1}^{n-1} A_{ik}X_k}{A_{ii}},i=2,\cdot\cdot\cdot,n\end{cases}</script><hr><hr><h3 id="Fortran代码实现"><a href="#Fortran代码实现" class="headerlink" title="Fortran代码实现"></a><strong>Fortran代码实现</strong></h3><pre class=" language-lang-fortran"><code class="language-lang-fortran">module parameter    implicit none    integer, parameter :: dp=8end module parametermodule matrix_solve    use parameter       contains    !上三角方程    ! A(n,n): 左矩阵    ! B(n): 右矩阵    ! X(n): 待求解矩阵    ! N: 输入的矩阵维数    !    subroutine uptri_equation_solve(A,B,X,N)        implicit none        integer,INTENT(IN) :: N         integer :: i ,j        real(kind=dp),INTENT(IN) :: A(N,N),B(N)        real(kind=dp),INTENT(OUT) :: X(N)        X(n)=B(n)/A(n,n)        do i=n-1,1,-1            X(i)=B(i)            do j=i+1,N                 X(i)=X(i)-A(i,j)*X(j)            enddo            X(i)=X(i)/A(i,i)        enddo    end subroutine uptri_equation_solve    !下三角矩阵    ! A(n,n): 左矩阵    ! B(n): 右矩阵    ! X(n): 待求解矩阵    ! N: 输入的矩阵维数    !    subroutine downtri_equation_solve(A,B,X,N)        implicit none        integer,INTENT(IN) :: N         integer :: i ,j        real(kind=dp),INTENT(IN) :: A(N,N),B(N)        real(kind=dp),INTENT(OUT) :: X(N)        X(1)=B(1)/A(1,1)        do i=2,n            X(i)=B(i)            do j=1,i-1                X(i)=X(i)-A(i,j)*X(j)            enddo            X(i)=X(i)/A(i,i)        enddo    end subroutine downtri_equation_solveend module</code></pre>]]></content>
      
      
      <categories>
          
          <category> Fortran学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fortran_learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AELAS安装教程</title>
      <link href="/2020/04/26/aelas-an-zhuang-jiao-cheng/"/>
      <url>/2020/04/26/aelas-an-zhuang-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="AELAS安装教程"><a href="#AELAS安装教程" class="headerlink" title="AELAS安装教程"></a><strong>AELAS安装教程</strong></h2><p>结合VASP使用的弹性常数计算软件</p><h3 id="软件下载地址"><a href="#软件下载地址" class="headerlink" title="软件下载地址"></a>软件下载地址</h3><p>作者网址：<a href="https://sites.google.com/site/zrfbuaa/softwares/aelas" target="_blank" rel="noopener">https://sites.google.com/site/zrfbuaa/softwares/aelas</a>   </p><p>注：可能要翻墙才行</p><h3 id="安装编译"><a href="#安装编译" class="headerlink" title="安装编译"></a>安装编译</h3><p>1 解压文件</p><pre class=" language-lang-bash"><code class="language-lang-bash">tar -zxvf AELAS-1.0.0.tar.gz</code></pre><p>2 安装spglib库<br>进入 AELAS里的 spglib文件夹</p><pre class=" language-lang-bash"><code class="language-lang-bash">#在linux终端操作，一步一步运行cd AELAS-1.0.0cd spglib-1.9.9mkdir _buildcd _buildcmake ..makemake installcd ../..</code></pre><p>3 安装AELAS</p><p>进入 AELAS里的 src文件夹，注意 makefile文件里默认的是ifort编译器。</p><pre class=" language-lang-bash"><code class="language-lang-bash">cd ./srcmake#会在AELAS/bin文件里生成可执行文件AELAS</code></pre><p>4 添加环境变量</p><pre class=" language-lang-bash"><code class="language-lang-bash">vim ~/.bashrc #打开后按键盘上的 i 进入编辑模式#添加下列命令到bashrc中export PATH=/dir/bin:$PATH #dir:AELAS安装路径#添加完后，输入 :wq ，退出回到终端source ~/.bashrc</code></pre><h3 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a>运行命令</h3><pre class=" language-lang-bash"><code class="language-lang-bash">AELAS</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算软件安装教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>晶胞转换</title>
      <link href="/2020/04/25/jing-bao-zhuan-huan/"/>
      <url>/2020/04/25/jing-bao-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<h2 id="使用spglib将原胞的POSCAR重整为惯用晶胞的POSCAR的练习"><a href="#使用spglib将原胞的POSCAR重整为惯用晶胞的POSCAR的练习" class="headerlink" title="使用spglib将原胞的POSCAR重整为惯用晶胞的POSCAR的练习"></a><strong>使用spglib将原胞的POSCAR重整为惯用晶胞的POSCAR的练习</strong></h2><p>默认POSCAR的原子坐标是分数坐标形式，后续慢慢学习如何转化坐标和将惯用晶胞转为原胞。</p><p>需要的三个python脚本</p><pre class=" language-lang-txt"><code class="language-lang-txt">read_poscar.pyreposcar.pyrun.py</code></pre><p>read_poscar.py</p><pre class=" language-lang-python"><code class="language-lang-python">import spglibimport numpy as npimport osimport linecacheclass read_poscar(object):    def __init__(        self,        struct=None,        pos_name=None,        lattice_index=None,        lat=None,        lat_recell=None,        atomname=None,        atomnum=None,        postype=None,        pos=None,        spg_number=None,    ):        self.struct = linecache.getlines("POSCAR")        # read POSCAR to get some paramatrics: sys_name; lattice; atom_name; atom_number; atom_position        # and get spacegroup_number        poscar = [line.strip() for line in self.struct]        num = len(poscar)        self.pos_name = poscar[0].split()        self.lat_index = poscar[1].split()        self.lattice_index = float(self.lat_index[0])        # matrics of lattice vector        lat_vector = np.zeros((3, 3))        index = 0        for latt in poscar[2:5]:            latt = latt.split()            lat_vector[index, :] = latt[0:3]            index += 1        self.lattice = lat_vector        self.atomname = poscar[5].split()        self.atomnum = poscar[6].split()        self.postype = poscar[7].split()        atom_len=len(self.atomname)        # matrics of atom position        i = num - 8        position_vector = np.zeros((i, 3))        index = 0        for poss in poscar[8:num]:            poss = poss.split()            #position_vector[index, 0:3] = poss[0:3]            position_vector[index,0] = poss[0]            position_vector[index,1] = poss[1]            position_vector[index,2] = poss[2]            index += 1        self.lat = lat_vector * self.lattice_index        self.pos = position_vector        atom_numbers = [1,] * (int(self.atomnum[0]))#+int(self.atomnum[1]))        cell = (self.lat, self.pos, atom_numbers)        database = spglib.get_symmetry_dataset(            cell, symprec=1e-3        )        self.spg_number = database["number"]    def system_name(self):        return self.pos_name    def latt_index(self):        return self.lattice_index    def latti(self):        return self.lattice    def atom_name(self):        return self.atomname    def atom_number(self):        return self.atomnum    def position_type(self):        return self.postype    def positions(self):        return self.pos    def spacegroup_num(self):        return self.spg_number</code></pre><p>reposcar.py</p><pre class=" language-lang-python"><code class="language-lang-python">import osimport numpy as npimport read_poscar as readposimport spglibclass recell(object):    def __init__(        self,        spg_num=None,        lattindex=None,        latt=None,        atomname=None,        atomnum=None,        postype=None,        position=None,        cell_lattice=None,        cell_position=None,        cell_atomnum=None,        to_pricell = None    ):        # read the origmitive cell        self.spg_num = readpos.read_poscar().spacegroup_num()        self.lattindex = readpos.read_poscar().latt_index()        self.latt = readpos.read_poscar().latti()        self.atomname = readpos.read_poscar().atom_name()        self.atomnum = readpos.read_poscar().atom_number()        self.postype = readpos.read_poscar().position_type()        self.position = readpos.read_poscar().positions()        orignumbers = []        for i in np.arange(0, len(self.atomname)):            for j in np.arange(0, int(self.atomnum[i]), 1):                orignumbers.append(i + 1)        origlattice = self.latt * self.lattindex        origpositon = self.position        origcell = (origlattice, origpositon, orignumbers)        if(to_pricell==False):        # refine cell            self.cell_lattice, re_position, re_numbers = spglib.standardize_cell(                cell=origcell, symprec=1e-3, to_primitive=False            )        else:            self.cell_lattice, re_position, re_numbers = spglib.standardize_cell(                cell=origcell, symprec=1e-3, to_primitive=True            )        # 主要对坐标进行重新排序        re_position_list = list(re_position)        zipped = list(zip(re_numbers, re_position_list))        zipsorted = sorted(zipped, key=lambda x: (x[0]))        re_numbers_sort, re_positon_sort = zip(*zipsorted)        self.cell_position = np.array(re_positon_sort)        self.cell_atomnum = []        for i in np.arange(0, len(self.atomnum), 1):            num = int(self.atomnum[i]) * (len(re_numbers_sort) / len(orignumbers))            self.cell_atomnum.append(num)        # write the refine cell        writepos = open("RECELL", mode="w")        print("recell_poscar", file=writepos)        print("1.0", file=writepos)        for m in np.arange(0, 3, 1):            print(                format(self.cell_lattice[m, 0], ".10f"),                "   ",                format(self.cell_lattice[m, 1], ".10f"),                "   ",                format(self.cell_lattice[m, 2], ".10f"),                file=writepos,            )        for j in np.arange(0, len(self.atomname), 1):            print(self.atomname[j], file=writepos, end=" ")        print(end="\n", file=writepos)        for l in np.arange(0, len(self.atomname), 1):            print(int(self.cell_atomnum[l]), end=" ", file=writepos)        print(end="\n", file=writepos)        print(self.postype[0], file=writepos)        for n in np.arange(0, self.cell_position.shape[0], 1):            print(                format(self.cell_position[n, 0], ".10f"),                "   ",                format(self.cell_position[n, 1], ".10f"),                "   ",                format(self.cell_position[n, 2], ".10f"),                file=writepos,            )        writepos.close()    def latti(self):        return self.cell_lattice    def atom_number(self):        return self.cell_atomnum    def positions(self):        return self.cell_position</code></pre><p>run.py</p><pre class=" language-lang-python"><code class="language-lang-python">import reposcarreposcar.recell(to_pricell=False) #转化为惯用晶胞reposcar.recell(to_pricell=True)  #转化为原胞</code></pre><p>例子：</p><p>铀</p><p>原胞</p><pre class=" language-lang-POSCAR"><code class="language-lang-POSCAR">Primitive Cell  1.000000    1.40175686596237   -2.92091081962523    0.00000000000000    1.40175686596237    2.92091081962523    0.00000000000000    0.00000000000000    0.00000000000000    4.90466659076150  U    2DIRECT    0.9016657719149295    0.0983342280850705    0.7500000000000000    0.0983342280850705    0.9016657719149295    0.2500000000000000</code></pre><p>输出晶胞</p><pre class=" language-lang-POSCAR"><code class="language-lang-POSCAR">recell_poscar1.02.8035137319     0.0000000000     0.00000000000.0000000000     5.8418216393     0.00000000000.0000000000     0.0000000000     4.9046665908U 4 DIRECT0.0000000000     0.0983342281     0.25000000000.5000000000     0.4016657719     0.75000000000.5000000000     0.5983342281     0.25000000000.0000000000     0.9016657719     0.7500000000</code></pre><p>ThO2</p><p>原胞</p><pre class=" language-lang-POSCAR"><code class="language-lang-POSCAR">ThO2                                       1.00000000000000          0.0000000000000000    2.8080796680000000    2.8080796680000000     2.8080796680000000    0.0000000000000000    2.8080796680000000     2.8080796680000000    2.8080796680000000    0.0000000000000000   Th   O      1     2Direct  0.0000000000000000  0.0000000000000000  0.0000000000000000  0.2500000000000000  0.2500000000000000  0.2500000000000000  0.7500000000000000  0.7500000000000000  0.7500000000000000</code></pre><p>输出晶胞</p><pre class=" language-lang-POSCAR"><code class="language-lang-POSCAR">recell_poscar1.05.6161593360     0.0000000000     0.00000000000.0000000000     5.6161593360     0.00000000000.0000000000     0.0000000000     5.6161593360Th O 4 8 Direct0.0000000000     0.0000000000     0.00000000000.0000000000     0.5000000000     0.50000000000.5000000000     0.0000000000     0.50000000000.5000000000     0.5000000000     0.00000000000.2500000000     0.7500000000     0.75000000000.2500000000     0.2500000000     0.75000000000.2500000000     0.2500000000     0.25000000000.2500000000     0.7500000000     0.25000000000.7500000000     0.7500000000     0.25000000000.7500000000     0.2500000000     0.25000000000.7500000000     0.2500000000     0.75000000000.7500000000     0.7500000000     0.7500000000</code></pre><hr><p>铀转化为原胞</p><p>输入晶胞</p><pre class=" language-lang-POSCAR"><code class="language-lang-POSCAR">recell_poscar1.02.8035137319     0.0000000000     0.00000000000.0000000000     5.8418216393     0.00000000000.0000000000     0.0000000000     4.9046665908U 4 DIRECT0.0000000000     0.0983342281     0.25000000000.5000000000     0.4016657719     0.75000000000.5000000000     0.5983342281     0.25000000000.0000000000     0.9016657719     0.7500000000</code></pre><p>输出原胞</p><pre class=" language-lang-POSCAR"><code class="language-lang-POSCAR">recell_poscar1.01.4017568659     -2.9209108196     0.00000000001.4017568659     2.9209108196     0.00000000000.0000000000     0.0000000000     4.9046665908U 2 DIRECT0.9016657719     0.0983342281     0.25000000000.0983342281     0.9016657719     0.7500000000</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算脚本练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VASP脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fortran运算符</title>
      <link href="/2020/04/22/fortran-yun-suan-fu-zong-jie/"/>
      <url>/2020/04/22/fortran-yun-suan-fu-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="Fortran运算符总结"><a href="#Fortran运算符总结" class="headerlink" title="Fortran运算符总结"></a><strong>Fortran运算符总结</strong></h2><p><strong>关系运算符</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">Fortran77</th><th style="text-align:center">Fortran95</th><th style="text-align:center">意  义</th></tr></thead><tbody><tr><td style="text-align:center">.EQ.</td><td style="text-align:center">==</td><td style="text-align:center">等于</td></tr><tr><td style="text-align:center">.NE.</td><td style="text-align:center">/=</td><td style="text-align:center">不等于</td></tr><tr><td style="text-align:center">.GT.</td><td style="text-align:center">&gt;</td><td style="text-align:center">大于</td></tr><tr><td style="text-align:center">.GE.</td><td style="text-align:center">&gt;=</td><td style="text-align:center">大于等于</td></tr><tr><td style="text-align:center">.LT.</td><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td></tr><tr><td style="text-align:center">.LE.</td><td style="text-align:center">&lt;=</td><td style="text-align:center">小于等于</td></tr></tbody></table></div><p><strong>注：建议使用新版的运算符，方便代码阅读</strong></p><hr><p><strong>组合逻辑运算符</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">意  义</th></tr></thead><tbody><tr><td style="text-align:center">.AND.</td><td style="text-align:center">逻辑与</td></tr><tr><td style="text-align:center">.OR.</td><td style="text-align:center">逻辑或</td></tr><tr><td style="text-align:center">.EQV.</td><td style="text-align:center">逻辑等值</td></tr><tr><td style="text-align:center">.NEQV.</td><td style="text-align:center">逻辑非等值</td></tr><tr><td style="text-align:center">.NOT.</td><td style="text-align:center">逻辑非</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">L1</th><th style="text-align:center">.NOT.L1</th></tr></thead><tbody><tr><td style="text-align:center">.FALSE.</td><td style="text-align:center">.TRUE.</td></tr><tr><td style="text-align:center">.TRUE.</td><td style="text-align:center">.FALSE.</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Fortran学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fortran_learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>能带计算</title>
      <link href="/2020/04/19/neng-dai-tu-de-ji-suan/"/>
      <url>/2020/04/19/neng-dai-tu-de-ji-suan/</url>
      
        <content type="html"><![CDATA[<h2 id="电子结构的计算流程"><a href="#电子结构的计算流程" class="headerlink" title="电子结构的计算流程"></a><strong>电子结构的计算流程</strong></h2><p>高对称点生成和后期处理使用vaspkit-1.1。</p><p><strong>注：该方法只针对原胞。</strong></p><h3 id="PBE能带计算流程"><a href="#PBE能带计算流程" class="headerlink" title="PBE能带计算流程"></a><strong>PBE能带计算流程</strong></h3><p>必要的文件</p><pre class=" language-lang-bash"><code class="language-lang-bash">INCAR-scfINCAR-bandKPOINTSPOTCARPOSCAR #优化后的原胞run_banddos.sh</code></pre><p>run_banddos.sh的脚本设置如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">#!/bin/bash#优化后的初始POSCARcat > POSCAR <<!Primitive Cell  1.000000    0.00000000000000    2.73423319845426    2.73423319845426    2.73423319845426    0.00000000000000    2.73423319845426    2.73423319845426    2.73423319845426    0.00000000000000  Si   2DIRECT    0.0000000000000000    0.0000000000000000    0.0000000000000000    0.2500000000000000    0.2500000000000000    0.2500000000000000!cat > KPOINTS <<!A0M12 12 120  0  0!#基于seek-path自动生成高对称点vaspkit -task 303#得到KPATH.in 和 HIGH_SYMMETRY_POINTS 可以自行修改cat > INCAR-scf <<!ISTART=0ICHARG=2PREC=AccurateGGA = PEADDGRID =.TRUE.# Electronic relaxationENCUT=500EDIFF=1E-8EDIFFG=-0.001ISMEAR=0SIGMA = 0.05POTIM=0.20# Other Tags#PSTRESS=# Write flagsLWAVE=.TRUE.LCHARG=.TRUE.!cat > INCAR-band <<!Global Parameters  ISTART =  1            (Read existing wavefunction; if there)  ICHARG =  11            (Non-self-consistent: GGA/LDA band structures)  LREAL  = F             (Projection operators: automatic)  ENCUT  =  500          (Cut-off energy for plane wave basis set, in eV)   PREC   =  Accurate       (Precision level)    LWAVE  = .TRUE.        (Write WAVECAR or not)  LCHARG = .TRUE.        (Write CHGCAR or not)   ADDGRID= .TRUE.        (Increase grid; helps GGA convergence)   # LVTOT  = .TRUE.      (Write total electrostatic potential into LOCPOT or not)  # LVHAR  = .TRUE.      (Write ionic + Hartree electrostatic potential into LOCPOT or not)  # NELECT =             (No. of electrons: charged cells; be careful)  # LPLANE = .TRUE.      (Real space distribution; supercells)  # NPAR   = 4           (Max is no. nodes; don't set for hybrids)Electronic Relaxation  ISMEAR =  0            (Gaussian smearing; metals:1)  SIGMA  =  0.05         (Smearing value in eV; metals:0.2) # NELM   =  60           (Max electronic SCF steps)   # NELMIN =  4            (Min electronic SCF steps)  EDIFF  =  1E-08       (SCF energy convergence; in eV)   GGA  =  PE             (PBEsol exchange-correlation)  LORBIT=11              (plot projection band need to set)  NEDOS = 2000Ionic Relaxation # NELMIN =  6           (Min electronic SCF steps)   NSW    =  0            (Max electronic SCF steps)  IBRION =  -1           (Algorithm: 0-MD; 1-Quasi-New; 2-CG)  ISIF   =  2            (Stress/relaxation: 2-Ions, 3-Shape/Ions/V, 4-Shape/Ions)  EDIFFG = -0.001         (Ionic convergence; eV/AA)  #ISYM =  0              (Symmetry: 0=none; 2=GGA; 3=hybrids)!#自洽计算cp INCAR-scf INCARecho "scf"; time mpirun -np 16 vasp_stdrm INCAR#更换KPOINTS文件cp KPATH.in KPOINTScp INCAR-band INCARecho "band"; time mpirun -np 16 vasp_std#处理能带数据vaspkit -task n #根据下面说明自行选择### 211) Band-Structure### 212) Projected Band-Structure for Selected Atom### 213) Projected Band-Structure for Each Element### 214) The Sum of Projected Band-Structure for Selected Atoms### 215) Projected Band-Structure by Element Weight###</code></pre><p>运行后得到包含能带数据的dat文件</p><p>Si的能带图：</p><p><img src="/img/Si_pbeband.png" width = "60%" height = "60%" div align=center/></p><p><br /></p><p>Si的轨道投影能带:</p><p><img src="/img/Si_projband.png" width = "60%" height = "60%" div align=center/></p><p><br /><br><br /></p><hr><h3 id="杂化轨道能带计算流程"><a href="#杂化轨道能带计算流程" class="headerlink" title="杂化轨道能带计算流程"></a><strong>杂化轨道能带计算流程</strong></h3><p>必要的文件</p><pre class=" language-lang-bash"><code class="language-lang-bash">INCAR-scfINCAR-hseKPOINTSPOTCARPOSCAR #优化后的原胞run_hseband.sh</code></pre><p>run_hseband.sh脚本设置如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">#!/bin/bash#优化后的初始POSCARcat > POSCAR <<!Primitive Cell  1.000000    0.00000000000000    2.73423319845426    2.73423319845426    2.73423319845426    0.00000000000000    2.73423319845426    2.73423319845426    2.73423319845426    0.00000000000000  Si   2DIRECT    0.0000000000000000    0.0000000000000000    0.0000000000000000    0.2500000000000000    0.2500000000000000    0.2500000000000000!#基于seek-path自动生成高对称点vaspkit -task 303#得到KPATH.in 和 HIGH_SYMMETRY_POINTS 可以自行修改#由于HSE计算量很大，对于点的数量一定要适当vaspkit -task 251#生成包含SCF的k-mesh和权重为0的用于HSE-band的k-path的KPOINTS文件cat > INCAR-scf <<!ISTART=0ICHARG=2PREC=AccurateGGA = PEADDGRID =.TRUE.# Electronic relaxationENCUT=500EDIFF=1E-8EDIFFG=-0.001ISMEAR=0SIGMA = 0.05POTIM=0.20# Other Tags#PSTRESS=# Write flagsLWAVE=.TRUE.LCHARG=.TRUE.!cat > INCAR-hse <<!Global Parameters  ISTART =  1            (Read existing wavefunction; if there)  ICHARG =  1            (Non-self-consistent: GGA/LDA band structures)  LREAL  = F             (Projection operators: automatic)  ENCUT  =  500          (Cut-off energy for plane wave basis set, in eV)   PREC   =  Accurate       (Precision level)    LWAVE  = .TRUE.        (Write WAVECAR or not)  LCHARG = .TRUE.        (Write CHGCAR or not)   ADDGRID= .TRUE.        (Increase grid; helps GGA convergence)   # LVTOT  = .TRUE.      (Write total electrostatic potential into LOCPOT or not)  # LVHAR  = .TRUE.      (Write ionic + Hartree electrostatic potential into LOCPOT or not)  # NELECT =             (No. of electrons: charged cells; be careful)  # LPLANE = .TRUE.      (Real space distribution; supercells)  # NPAR   = 4           (Max is no. nodes; don't set for hybrids)Electronic Relaxation  ISMEAR =  0            (Gaussian smearing; metals:1)  SIGMA  =  0.05         (Smearing value in eV; metals:0.2) # NELM   =  60           (Max electronic SCF steps)   # NELMIN =  4            (Min electronic SCF steps)  EDIFF  =  1E-08       (SCF energy convergence; in eV)   GGA  =  PE             (PBEsol exchange-correlation)  LORBIT=11  NEDOS = 5000 Ionic Relaxation # NELMIN =  6           (Min electronic SCF steps)   NSW    =  0            (Max electronic SCF steps)  IBRION =  -1           (Algorithm: 0-MD; 1-Quasi-New; 2-CG)  ISIF   =  2            (Stress/relaxation: 2-Ions, 3-Shape/Ions/V, 4-Shape/Ions)  EDIFFG = -0.001         (Ionic convergence; eV/AA)  ISYM =  0              (Symmetry: 0=none; 2=GGA; 3=hybrids)#HSE06 Calculation  LHFCALC= .TRUE.       (Activate HF)  AEXX   =  0.25        (25% HF exact exchange, adjusted this value to reproduce experimental band gap)  HFSCREEN= 0.2         (Switch to screened exchange; e.g. HSE06)  ALGO   =  Damped         (Electronic Minimisation Algorithm; ALGO=58)        TIME   =  0.4         (Timestep for IALGO5X)  PRECFOCK= Normal      (HF FFT grid)   # NKRED    = 2        (Reduce k-grid-even only, see also NKREDX, NKREDY and NKREDZ)  # HFLMAX   = 4        (HF cut-off: 4d, 6f)  # LDIAG    = .TRUE.   (Diagnolise Eigenvalues) !#SCF计算，可省略,主要得到WAVECAR波函数，可加速HSE计算速度cp INCAR-scf INCARecho "scf"; time mpirun -np 16 vasp_stdrm INCAR#HSE计算cp INCAR-hse INCARecho "hse"; time mpirun -np 16 vasp_stdvaspkit -task n #根据下述说明自行选择##  250) Generate KPOINTS Including Irreducible Kmesh and Band Edges ##  251) Generate KPOINTS File for Hybrid Band-Structure Calculation ##  252) Get Band-Structure for Hybrid-DFT Calculation               ##  253) Get Projected Band-Structure for Selected Atoms             ##  254) Get Projected Band-Structure for Each ELement               ##  255) Get the Sum of Projected Band-Structure for Selected Atoms  ##  256) Projected Band-Structure by Element Weight</code></pre><p><br /></p><hr><h3 id="PBE-HSE-SOC计算能带"><a href="#PBE-HSE-SOC计算能带" class="headerlink" title="PBE(HSE)+SOC计算能带"></a><strong>PBE(HSE)+SOC计算能带</strong></h3><p>参照 PBE(HSE)计算能带。</p><p>在INCAR中添加如下参数：</p><pre class=" language-lang-txt"><code class="language-lang-txt">Spin-Orbit Coupling Calculation  ISPIN  =  2  NELMIN =  6            (Min electronic SCF steps)   LSORBIT    = .TRUE.    (Activate SOC)  GGA_COMPAT = .FALSE.   (Apply spherical cutoff on gradient field) # VOSKOWN    =  1        (Enhances the magnetic moments and the magnetic energies)  LMAXMIX    =  2        (For d elements increase LMAXMIX to 4, f: LMAXMIX = 6)  SAXIS    =  0 0 1      (Direction of the magnetic field)  # MAGMOM   =  0 0 3    (Set this parameters manually, Local magnetic moment parallel to SAXIS, 3*NIONS*1.0 for non-collinear magnetic systems)  NBANDS   =  32         (Set this parameters manually, 2 * number of bands of collinear-run)</code></pre><p>注：NBAND最好为PBE(HSE)中能带数的整数倍。HSE+SOC计算流程未测试，不知道会不会成功。下面是我当初计算2D-Tl2O的HSE+SOC能带的流程，主要给出INCAR的设置。</p><p>第一步：SCF+SOC计算</p><pre class=" language-lang-txt"><code class="language-lang-txt">Global Parameters  ISTART = 0             (Read existing wavefunction; if there)  ICHARG =  2            (Non-self-consistent: GGA/LDA band structures)  LREAL  = F             (Projection operators: automatic)  ENCUT  =  500          (Cut-off energy for plane wave basis set, in eV)   PREC   =  Accurate       (Precision level)    LWAVE  = .TRUE.        (Write WAVECAR or not)  LCHARG = .TRUE.        (Write CHGCAR or not)   ADDGRID= .TRUE.        (Increase grid; helps GGA convergence)   # LVTOT  = .TRUE.      (Write total electrostatic potential into LOCPOT or not)  # LVHAR  = .TRUE.      (Write ionic + Hartree electrostatic potential into LOCPOT or not)  # NELECT =             (No. of electrons: charged cells; be careful)  # LPLANE = .TRUE.      (Real space distribution; supercells)  # NPAR   = 4           (Max is no. nodes; don't set for hybrids)Electronic Relaxation  ISMEAR =  0            (Gaussian smearing; metals:1)  SIGMA  =  0.05         (Smearing value in eV; metals:0.2) # NELM   =  60           (Max electronic SCF steps)   # NELMIN =  4            (Min electronic SCF steps)  EDIFF  =  1E-06        (SCF energy convergence; in eV)   GGA  =  PE             (PBEsol exchange-correlation)Ionic Relaxation # NELMIN =  6           (Min electronic SCF steps)   NSW    =  0            (Max electronic SCF steps)  IBRION =  -1           (Algorithm: 0-MD; 1-Quasi-New; 2-CG)  ISIF   =  2            (Stress/relaxation: 2-Ions, 3-Shape/Ions/V, 4-Shape/Ions)  EDIFFG = -0.01         (Ionic convergence; eV/AA)  ISYM =  0              (Symmetry: 0=none; 2=GGA; 3=hybrids)Spin-Orbit Coupling Calculation  ISPIN  =  2  NELMIN =  6            (Min electronic SCF steps)   LSORBIT    = .TRUE.    (Activate SOC)                                                             GGA_COMPAT = .FALSE.   (Apply spherical cutoff on gradient field)                 # VOSKOWN    =  1        (Enhances the magnetic moments and the magnetic energies)                                                         LMAXMIX    =  2        (For d elements increase LMAXMIX to 4, f: LMAXMIX = 6)          SAXIS    =  0 0 1      (Direction of the magnetic field)                             # MAGMOM   =  0 0 3    (Set this parameters manually, Local magnetic moment parallel to SAXIS, 3*NIONS*1.0 for non-collinear magnetic systems) # NBANDS   =  32         (Set this parameters manually, 2 * number of bands of collinear-run)</code></pre><p>得到IBZKPT的K点<br>能带计算K点的生成参照HSE计算</p><p>第二步：打开杂化HSE</p><pre class=" language-lang-txt"><code class="language-lang-txt">Global Parameters  ISTART =  1            (Read existing wavefunction; if there)  ICHARG =  2            (Non-self-consistent: GGA/LDA band structures)  LREAL  = F             (Projection operators: automatic)  ENCUT  =  500          (Cut-off energy for plane wave basis set, in eV)   PREC   =  Accurate       (Precision level)    LWAVE  = .TRUE.        (Write WAVECAR or not)  LCHARG = .TRUE.        (Write CHGCAR or not)   ADDGRID= .TRUE.        (Increase grid; helps GGA convergence)   # LVTOT  = .TRUE.      (Write total electrostatic potential into LOCPOT or not)  # LVHAR  = .TRUE.      (Write ionic + Hartree electrostatic potential into LOCPOT or not)  # NELECT =             (No. of electrons: charged cells; be careful)  # LPLANE = .TRUE.      (Real space distribution; supercells)  # NPAR   = 4           (Max is no. nodes; don't set for hybrids)Electronic Relaxation  ISMEAR =  0            (Gaussian smearing; metals:1)  SIGMA  =  0.15         (Smearing value in eV; metals:0.2) # NELM   =  60           (Max electronic SCF steps)   # NELMIN =  4            (Min electronic SCF steps)  EDIFF  =  1E-06        (SCF energy convergence; in eV)   GGA  =  PE             (PBEsol exchange-correlation)Ionic Relaxation # NELMIN =  6           (Min electronic SCF steps)   NSW    =  0            (Max electronic SCF steps)  IBRION =  -1           (Algorithm: 0-MD; 1-Quasi-New; 2-CG)  ISIF   =  2            (Stress/relaxation: 2-Ions, 3-Shape/Ions/V, 4-Shape/Ions)  EDIFFG = -0.01         (Ionic convergence; eV/AA)  ISYM =  0              (Symmetry: 0=none; 2=GGA; 3=hybrids)Spin-Orbit Coupling Calculation  ISPIN  =  2  NELMIN =  6            (Min electronic SCF steps)   LSORBIT    = .TRUE.    (Activate SOC)                                                             GGA_COMPAT = .FALSE.   (Apply spherical cutoff on gradient field)                 # VOSKOWN    =  1        (Enhances the magnetic moments and the magnetic energies)                                                         LMAXMIX    =  2        (For d elements increase LMAXMIX to 4, f: LMAXMIX = 6)          SAXIS    =  0 0 1      (Direction of the magnetic field)                             # MAGMOM   =  0 0 3    (Set this parameters manually, Local magnetic moment parallel to SAXIS, 3*NIONS*1.0 for non-collinear magnetic systems)  NBANDS   =  32         (Set this parameters manually, 2 * number of bands of collinear-run)HSE06 Calculation  LHFCALC= .TRUE.       (Activate HF)  AEXX   =  0.25        (25% HF exact exchange, adjusted this value to reproduce experimental band gap)  HFSCREEN= 0.2         (Switch to screened exchange; e.g. HSE06)  ALGO   =  Damped         (Electronic Minimisation Algorithm; ALGO=58)        TIME   =  0.4         (Timestep for IALGO5X)  PRECFOCK= Normal      (HF FFT grid)   # NKRED    = 2        (Reduce k-grid-even only, see also NKREDX, NKREDY and NKREDZ)  # HFLMAX   = 4        (HF cut-off: 4d, 6f)  # LDIAG    = .TRUE.   (Diagnolise Eigenvalues)</code></pre><p>注：选择读取上一步的WAVECAR可以加速这一步的计算，如果报错，可以不读取WAVECAR直接计算。</p><hr><hr><h3 id="态密度计算"><a href="#态密度计算" class="headerlink" title="态密度计算"></a><strong>态密度计算</strong></h3><p><strong>注：与能带计算差不多，只是不需要修改K点。也可以直接用能带计算中得到的态密度。</strong></p><p>必要的文件：</p><pre class=" language-lang-txt"><code class="language-lang-txt">INCAR-scfINCAR-dosKPOINTSPOTCARrun_dos.sh</code></pre><pre class=" language-lang-bash"><code class="language-lang-bash">#!/bin/bashcat > POSCAR <<!Primitive Cell  1.000000    0.00000000000000    2.73423319845426    2.73423319845426    2.73423319845426    0.00000000000000    2.73423319845426    2.73423319845426    2.73423319845426    0.00000000000000  Si   2DIRECT    0.0000000000000000    0.0000000000000000    0.0000000000000000    0.2500000000000000    0.2500000000000000    0.2500000000000000!cat > KPOINTS <<!A0M21 21 210  0  0!cat > INCAR-scf <<!ISTART=0ICHARG=2PREC=AccurateGGA = PEADDGRID =.TRUE.# Electronic relaxationENCUT=500EDIFF=1E-8EDIFFG=-0.001ISMEAR=0SIGMA = 0.05POTIM=0.20# Other Tags#PSTRESS=# Write flagsLWAVE=.TRUE.LCHARG=.TRUE.!cat > INCAR-dos <<!Global Parameters  ISTART =  1            (Read existing wavefunction; if there)  ICHARG =  11            (Non-self-consistent: GGA/LDA band structures)  LREAL  = F             (Projection operators: automatic)  ENCUT  =  500          (Cut-off energy for plane wave basis set, in eV)   PREC   =  Accurate       (Precision level)    LWAVE  = .TRUE.        (Write WAVECAR or not)  LCHARG = .TRUE.        (Write CHGCAR or not)   ADDGRID= .TRUE.        (Increase grid; helps GGA convergence)   # LVTOT  = .TRUE.      (Write total electrostatic potential into LOCPOT or not)  # LVHAR  = .TRUE.      (Write ionic + Hartree electrostatic potential into LOCPOT or not)  # NELECT =             (No. of electrons: charged cells; be careful)  # LPLANE = .TRUE.      (Real space distribution; supercells)  # NPAR   = 4           (Max is no. nodes; don't set for hybrids)Electronic Relaxation  ISMEAR =  0            (Gaussian smearing; metals:1)  SIGMA  =  0.05         (Smearing value in eV; metals:0.2) # NELM   =  60           (Max electronic SCF steps)   # NELMIN =  4            (Min electronic SCF steps)  EDIFF  =  1E-08       (SCF energy convergence; in eV)   GGA  =  PE             (PBEsol exchange-correlation)  LORBIT=11              (plot projection band need to set)  NEDOS = 2000Ionic Relaxation # NELMIN =  6           (Min electronic SCF steps)   NSW    =  0            (Max electronic SCF steps)  IBRION =  -1           (Algorithm: 0-MD; 1-Quasi-New; 2-CG)  ISIF   =  2            (Stress/relaxation: 2-Ions, 3-Shape/Ions/V, 4-Shape/Ions)  EDIFFG = -0.001         (Ionic convergence; eV/AA)  #ISYM =  0              (Symmetry: 0=none; 2=GGA; 3=hybrids)!#自洽计算cp INCAR-scf INCARecho "scf"; time mpirun -np 16 vasp_stdrm INCAR#更换KPOINTS文件cp INCAR-dos INCARecho "dos"; time mpirun -np 16 vasp_stdvaspkit -task n #根据需要选择下面的参数，参照手册说明，有些需要给出元素，个数### 111) Total Density-of-States                                     ### 112) Projected Density-of-States for Selected Atoms              ### 113) Projected Density-of-States for Each Element                ### 114) The Sum of Projected Density-of-States for Selected Atoms   ### 115) The Sum of Projected DOS for Selected Atoms and Orbitals    ### 116) Local Density-of-States for Each Element                    ### 117) Total Density-of-States with Adjustable Smearing Width</code></pre><p>Si的band-dos图如下：</p><p><img src="/img/Si_banddos.png" width = "60%" height = "60%" div align=center/></p><p><br /></p><hr><h3 id="二维材料1T-Tl2O的能带示例"><a href="#二维材料1T-Tl2O的能带示例" class="headerlink" title="二维材料1T-Tl2O的能带示例"></a><strong>二维材料1T-Tl2O的能带示例</strong></h3><p><strong>PBE</strong></p><p>1T-Tl2O的能带态密度：</p><p><img src="/img/Tl2O_banddos.png" width = "60%" height = "60%" div align=center/></p><p><br /></p><p>1T-Tl2O的投影能带：</p><p><img src="/img/Tl2O_projband.png" width = "60%" height = "60%" div align=center/></p><p><img src="/img/O_projband.png" width = "60%" height = "60%" div align=center/></p><p><img src="/img/Tl_projband.png" width = "80%" height = "80%" div align=center/></p><p><strong>HSE</strong></p><p>1T-Tl2O的能带态密度：</p><p><img src="/img/Tl2O_hseband.png" width = "60%" height = "60%" div align=center/></p><p><br /></p><p>1T-Tl2O的投影能带：</p><p><img src="/img/Tl2O_hseprojband.png" width = "60%" height = "60%" div align=center/></p><p><img src="/img/O_hseprojband.png" width = "60%" height = "60%" div align=center/></p><p><img src="/img/Tl_hseprojband.png" width = "80%" height = "80%" div align=center/></p><p><strong>HSE+SOC</strong></p><p><img src="/img/1T.png" width = "60%" height = "60%" div align=center/></p>]]></content>
      
      
      <categories>
          
          <category> VASP计算笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VASP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KPOINTS测试</title>
      <link href="/2020/04/18/k-dian-ce-shi/"/>
      <url>/2020/04/18/k-dian-ce-shi/</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">    MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: "none" });</script><h1 id="KPOINTS-或-KSPACING-测试"><a href="#KPOINTS-或-KSPACING-测试" class="headerlink" title="KPOINTS 或 KSPACING 测试"></a><strong>KPOINTS 或 KSPACING 测试</strong></h1><p>必要输入文件：   </p><pre class=" language-lang-bash"><code class="language-lang-bash">k_test.shPOTCARINCAR和POSCAR可在k_test.sh中设置，也可独立给出</code></pre><p>脚本1(k_test.sh):  KPOINTS测试</p><pre class=" language-lang-bash"><code class="language-lang-bash">#!/bin/bash#生成vasp静态计算的INCARcat > INCAR_static <<!Global Parameters  ISTART =  0            (Read existing wavefunction; if there)  ICHARG =  2            (Non-self-consistent: GGA/LDA band structures)  LREAL  = .FALSE.       (Projection operators: automatic)  ENCUT  =  500           (Cut-off energy for plane wave basis set, in eV)  PREC   =  Accurate     (Precision level)    LWAVE  = .FALSE.       (Write WAVECAR or not)  LCHARG = .FALSE.       (Write CHGCAR or not)   ADDGRID= .TRUE.        (Increase grid; helps GGA convergence)Electronic Relaxation  ISMEAR =  -5           (Gaussian smearing; metals:1)  #SIGMA  =  0.05        (Smearing value in eV; metals:0.2)  NELM   =  60           (Max electronic SCF steps)    NELMIN =  4            (Min electronic SCF steps)  EDIFF  =  1E-06        (SCF energy convergence; in eV)  GGA  =  PE             (PBEsol exchange-correlation)Ionic Relaxation  ISIF   =  2            (Stress/relaxation: 2-Ions, 3-Shape/Ions/V，4-Shape/Ions)  EDIFFG = -0.001        (Ionic convergence; eV/AA)  KSPACING = 0.10!cp INCAR_static INCAR#产生计算所需POSCARcat > POSCAR<<!Si81.0000000000    5.4687280000        0.0000000000        0.0000000000    0.0000000000        5.4687280000        0.0000000000    0.0000000000        0.0000000000        5.4687280000Si8Direct    0.0000000000        0.0000000000        0.0000000000    0.2500000000        0.7500000000        0.7500000000    0.5000000000        0.0000000000        0.5000000000    0.0000000000        0.5000000000        0.5000000000    0.5000000000        0.5000000000        0.0000000000    0.7500000000        0.2500000000        0.7500000000    0.7500000000        0.7500000000        0.2500000000    0.2500000000        0.2500000000        0.2500000000!for i in $(seq 6 3 15) #K点从6-24，步数为3do#生成KPOINTS文件，K点类型：Monkhorst-Pack (M) 或者 Gamma (G)cat > KPOINTS <<!Automatic mesh0Monkhorst-Pack$i $i $i0  0  0!echo "KPOINTS = $i" ; time mpirun -n 16 vasp_std #vasp并行运行命令，根据系统自行修改rm KPOINTS#提取计算得到的能量E=$(grep "TOTEN" OUTCAR | tail -1 | awk '{printf "%12.9f \n", $5 }')echo $i $E >>kpoints_energy.outdone</code></pre><p>提交脚本任务运行，成功结束后可以得到输出文件kpoints_enengy.out<br>可以使用OriginPro等画图工具画出kpoints-能量关系</p><p>Si的KPOINTS测试</p><p><img src="/img/Si_kpoints_test.png" width = "60%" height = "60%" div align=center/></p><p>根据收敛性，大概选择KPOINTS为$9\times9\times9$<br><br /><br><br /></p><hr><p>脚本2(k_test.sh):  KSPACING测试</p><pre class=" language-lang-bash"><code class="language-lang-bash">#!/bin/bash#产生计算所需POSCARcat > POSCAR<<!Si81.0000000000    5.4687280000        0.0000000000        0.0000000000    0.0000000000        5.4687280000        0.0000000000    0.0000000000        0.0000000000        5.4687280000Si8Direct    0.0000000000        0.0000000000        0.0000000000    0.2500000000        0.7500000000        0.7500000000    0.5000000000        0.0000000000        0.5000000000    0.0000000000        0.5000000000        0.5000000000    0.5000000000        0.5000000000        0.0000000000    0.7500000000        0.2500000000        0.7500000000    0.7500000000        0.7500000000        0.2500000000    0.2500000000        0.2500000000        0.2500000000!for i in $(seq 0.5 -0.05 0.1) #K点密度从0.5-0.1，步数为0.05do#生成vasp静态计算的INCARcat > INCAR_static <<!Global Parameters  ISTART =  0            (Read existing wavefunction; if there)  ICHARG =  2            (Non-self-consistent: GGA/LDA band structures)  LREAL  = .FALSE.       (Projection operators: automatic)  ENCUT  =  500           (Cut-off energy for plane wave basis set, in eV)  PREC   =  Accurate     (Precision level)    LWAVE  = .FALSE.       (Write WAVECAR or not)  LCHARG = .FALSE.       (Write CHGCAR or not)   ADDGRID= .TRUE.        (Increase grid; helps GGA convergence)Electronic Relaxation  ISMEAR =  -5           (Gaussian smearing; metals:1)  #SIGMA  =  0.05        (Smearing value in eV; metals:0.2)  NELM   =  60           (Max electronic SCF steps)    NELMIN =  4            (Min electronic SCF steps)  EDIFF  =  1E-06        (SCF energy convergence; in eV)  GGA  =  PE             (PBEsol exchange-correlation)Ionic Relaxation  ISIF   =  2            (Stress/relaxation: 2-Ions, 3-Shape/Ions/V，4-Shape/Ions)  EDIFFG = -0.001        (Ionic convergence; eV/AA)  KSPACING = $i   KGAMMA = .FALSE.       #(true: GAMMA; false: Monkhorst-Pack )!cp INCAR_static INCARecho "KPOINTS = $i" ; time mpirun -n 16 vasp_std #vasp并行运行命令，根据系统自行修改rm INCAR_staticrm INCAR#提取计算得到的能量E=$(grep "TOTEN" OUTCAR | tail -1 | awk '{printf "%12.9f \n", $5 }')echo $i $E >>kspace_energy.outdone</code></pre><p><strong>注：Auto mesh模式下。 $KPONITSnumber = max(1,|\vec{b}|/(2\pi\times{KSPACING}))$<br>另外，后续介绍中，主要使用的是KPOINTS文件，KSPACING可以根据自行需要选择使用。</strong></p><p>提交脚本任务运行，成功结束后可以得到输出文件kspace_enengy.out<br>可以使用OriginPro等画图工具画出k点密度-能量关系。 </p><p>Si的KSPACE测试</p><p><img src="/img/Si_kspace_test.png" width = "60%" height = "60%" div align=center/></p><p>根据能量收敛判断，选择K点密度为0.15较为合适。</p>]]></content>
      
      
      <categories>
          
          <category> VASP计算笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VASP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>截断能测试</title>
      <link href="/2020/04/18/encut-test/"/>
      <url>/2020/04/18/encut-test/</url>
      
        <content type="html"><![CDATA[<h1 id="截断能测试"><a href="#截断能测试" class="headerlink" title="截断能测试"></a><strong>截断能测试</strong></h1><p>必要输入文件：</p><pre class=" language-lang-bash"><code class="language-lang-bash">encut.sh  POTCAR  KPOINTS和POSCAR可以在encut.sh里设置，也可以独立给出。</code></pre><p>encut.sh脚本参考  </p><pre class=" language-lang-bash"><code class="language-lang-bash">#!/bin/bash#生成KPOINTS文件，KPOINTS不能与INCAR中的KSPACING参数共用，二选一#注：KPOINTS文件每行一定要顶格写，不能前面不能空格，不然可能会报错。cat > KPOINTS <<!A0M9  9  90  0  0!#产生计算所需POSCARcat > POSCAR<<!Si81.0000000000    5.4687280000        0.0000000000        0.0000000000    0.0000000000        5.4687280000        0.0000000000    0.0000000000        0.0000000000        5.4687280000Si8Direct    0.0000000000        0.0000000000        0.0000000000    0.2500000000        0.7500000000        0.7500000000    0.5000000000        0.0000000000        0.5000000000    0.0000000000        0.5000000000        0.5000000000    0.5000000000        0.5000000000        0.0000000000    0.7500000000        0.2500000000        0.7500000000    0.7500000000        0.7500000000        0.2500000000    0.2500000000        0.2500000000        0.2500000000!for i in $(seq 400 50 700) #截断能从450-800，步数为50do#生成vasp静态计算的INCARcat > INCAR_static <<!Global Parameters  ISTART =  0            (Read existing wavefunction; if there)  ICHARG =  2            (Non-self-consistent: GGA/LDA band structures)  LREAL  = .FALSE.       (Projection operators: automatic)  ENCUT  =  $i           (Cut-off energy for plane wave basis set, in eV)  PREC   =  Accurate     (Precision level)    LWAVE  = .FALSE.       (Write WAVECAR or not)  LCHARG = .FALSE.       (Write CHGCAR or not)   ADDGRID= .TRUE.        (Increase grid; helps GGA convergence)Electronic Relaxation  ISMEAR =  -5           (Gaussian smearing; metals:1)  #SIGMA  =  0.05        (Smearing value in eV; metals:0.2)  NELM   =  60           (Max electronic SCF steps)    NELMIN =  4            (Min electronic SCF steps)  EDIFF  =  1E-06        (SCF energy convergence; in eV)  GGA  =  PE             (PBEsol exchange-correlation)Ionic Relaxation  ISIF   =  2            (Stress/relaxation: 2-Ions, 3-Shape/Ions/V，4-Shape/Ions)  EDIFFG = -0.001        (Ionic convergence; eV/AA)  KSPACING = 0.10!cp INCAR_static INCARecho "ENCUT = $i eV" ; time mpirun -np 16 vasp_std #vasp并行运行命令，根据系统自行修改rm INCAR_staticrm INCAR#提取计算得到的能量E=$(grep "TOTEN" OUTCAR | tail -1 | awk '{printf "%12.9f \n", $5 }')echo $i $E >>encut_energy.outdone</code></pre><p>提交脚本任务运行，成功结束后可以得到输出文件encut_enengy.out<br>可以使用OriginPro等画图工具画出截断能-能量关系.  </p><p>Si的截断能测试：<br><img src="/img/Si_encut_test.png" width = "60%" height = "60%" div align=center/></p><p>根据能量的收敛性(收敛值大约达到$0.001eV/atom$)，我们选择截断能500 $eV$。</p>]]></content>
      
      
      <categories>
          
          <category> VASP计算笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VASP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>声子谱计算</title>
      <link href="/2020/04/18/sheng-zi-pu/"/>
      <url>/2020/04/18/sheng-zi-pu/</url>
      
        <content type="html"><![CDATA[<h2 id="声子谱计算"><a href="#声子谱计算" class="headerlink" title="声子谱计算"></a><strong>声子谱计算</strong></h2><p>主要使用phonopy软件计算声子谱。版本：phonopy-2.1.3</p><h3 id="密度泛函微软理论-线性响应方法-DFPT"><a href="#密度泛函微软理论-线性响应方法-DFPT" class="headerlink" title="密度泛函微软理论/线性响应方法 (DFPT)"></a><strong>密度泛函微软理论/线性响应方法 (DFPT)</strong></h3><p>必要的输入文件：  </p><pre class=" language-lang-sh"><code class="language-lang-sh">INCARKPOINTSPOTCAR-unitcell #优化得到的初始晶胞POTCARband.conf</code></pre><p>1 扩胞得到计算所需的POSCAR</p><pre class=" language-lang-bash"><code class="language-lang-bash">#在Linux终端直接运行命令#1. 生成超胞phonopy -d --dim="2 2 2" -c POSCAR-unitcell #--dim='2 2 2'表示'x y z'方扩的大小#2. 将生成的SPOSCAR拷贝成POSCARcp SPOSCAR POSCAR</code></pre><p>2 提交VASP计算</p><p>INCAR设置如下：</p><pre class=" language-lang-txt"><code class="language-lang-txt"> ISMEAR =  0            (Gaussian smearing) SIGMA  =  0.05         (Smearing value in eV) IBRION =  8            (determines the Hessian matrix using DFPT) EDIFF  =  1E-08        (SCF energy convergence; in eV)  PREC   =  Accurate     (Precision level)   ENCUT  =  500          (Cut-off energy for plane wave basis set, in eV)  IALGO  =  38           (Davidson block iteration scheme) LREAL  = .FALSE.       (Projection operators: false) LWAVE  = .FLASE.       (Write WAVECAR or not) LCHARG = .FLASE.       (Write CHGCAR or not)  ADDGRID= .TRUE.        (Increase grid; helps GGA convergence)  NSW    = 1 NELM   = 100 NELMDL = -5</code></pre><p>KPOINTS需适当减小，可以的话最好再进行一次收敛测试<br>注：KPOINTS文件每行一定要顶格写，不能前面不能空格，不然可能会报错。</p><pre class=" language-lang-bash"><code class="language-lang-bash">A0M3  3  30  0  0</code></pre><p>提交VASP计算</p><pre class=" language-lang-bash"><code class="language-lang-bash">#若未安装作业管理程序，可直接运行下段命令。若安装了作业管理程序，请参考作业理手册。例如PBS作业管理系统。mpirun -np 16 vasp_std > vasp.log</code></pre><p>PBS作业管理系统提交计算脚本 (根据需要命名，最好以.pbs 或者 .sh结尾)</p><pre class=" language-lang-bash"><code class="language-lang-bash">#!/bin/bash #PBS -N phono #PBS -j oe #PBS -l nodes=1:ppn=16 cd ${PBS_O_WORKDIR} mpirun -n 16  vasp_std >& vasp.log</code></pre><p>将所有文件放到一个文件夹，在终端运行<code>qsub *.pbs</code> or  <code>qsub *.sh</code>  </p><p>3 计算声子谱</p><p>准备band.conf文件，如下所示：(参数含义详见phonopy官网)</p><pre class=" language-lang-conf"><code class="language-lang-conf"> ATOM_NAME =Si DIM = 2 2 2 PRIMITIVE_AXES=Auto MP = 24 24 24 BAND =0.0 0.0 0.0  0.5 0.0 0.5  0.625  0.25  0.625, 0.375 0.375 0.75  00 0.0 0.0  0.5 0.5 0.5 BAND_POINTS = 101 FORCE_CONSTANTS= READ</code></pre><p>获取声子谱后处理步骤</p><pre class=" language-lang-bash"><code class="language-lang-bash"> #直接在终端运行 #1. 提取力常数，得到FORCE_CONSTANTS文件。 phonopy --fc vasprun.xml #2. 计算声子谱并保存为pdf格式 phonopy -c POSCAR-unitcell band.conf -p -s #3. 将声子谱进一步输出为数据文件，用于其它软件画图。 #旧版本phonopy bandplot  --gnuplot> phonon.out #新版本phonopy phonopy-bandplot --gnuplot > phonon.out #phonon.out文件中首行是高对称点在x轴上的坐标</code></pre><h3 id="有限位移方法"><a href="#有限位移方法" class="headerlink" title="有限位移方法"></a><strong>有限位移方法</strong></h3><p>必要的输入文件：  </p><pre class=" language-lang-sh"><code class="language-lang-sh">INCARKPOINTSINCAR-unitcell #优化得到的初始晶胞POTCARband.conf</code></pre><p>扩胞得到计算所需的POSCAR</p><pre class=" language-lang-bash"><code class="language-lang-bash">#在Linux终端直接运行命令#1. 生成超胞phonopy -d --dim="2 2 2" -c POSCAR-unitcell #--dim='2 2 2'表示'x y z'扩胞的大小#会得到一系列POSCAR-001，POSCAR-002,... 数量由对称性决定。#2. 建立disp-*文件夹，具体数量以生成POSCAR-*的数量决定。将POSCAR-POTCAR, INCAR, KPOINTS放入disp-*文件夹mkdir disp-001cp POSCAR-001 ./disp-001/POSCARcp POTCAR ./disp-001/POTCARcp INCAR ./disp-001/INCARcp KPOINTS ./disp-001/KPOINTS</code></pre><p>提交VASP计算</p><p>INCAR设置如下(静态计算)：</p><pre class=" language-lang-bash"><code class="language-lang-bash"> PREC = Accurate IBRION = -1 ENCUT = 500 EDIFF = 1.0e-08 EDIFFG = -0.001 ISMEAR = 0 SIGMA = 0.05 ALGO = 38 LREAL = .FALSE. LWAVE = .FALSE. LCHARG = .FALSE.</code></pre><p>KPOINTS需适当减小，可以的话最好再进行一次收敛测试<br>注：KPOINTS文件每行一定要顶格写，不能前面不能空格，不然可能会报错。</p><pre class=" language-lang-bash"><code class="language-lang-bash">A0M3  3  30  0  0</code></pre><p>提交VASP计算</p><pre class=" language-lang-bash"><code class="language-lang-bash">#若未安装作业管理程序，可直接运行下段命令。若安装了作业管理程序，请参考作理手册。例如PBS作业管理系统。mpirun -np 16 vasp_std > vasp.log</code></pre><p>PBS作业管理系统提交计算脚本 (根据需要命名，最好以.pbs 或者 .sh结尾)</p><pre class=" language-lang-bash"><code class="language-lang-bash">#!/bin/bash #PBS -N phono #PBS -j oe #PBS -l nodes=1:ppn=16 cd ${PBS_O_WORKDIR} mpirun -n 16  vasp_std >& vasp.log</code></pre><p>将所有文件放到一个文件夹，在终端运行<code>qsub *.pbs</code> or  <code>qsub *.sh</code>  </p><p>3 计算声子谱</p><p>准备band.conf文件，如下所示：(参数含义详见phonopy官网)</p><pre class=" language-lang-conf"><code class="language-lang-conf"> ATOM_NAME =Si DIM = 2 2 2 PRIMITIVE_AXES=Auto MP = 24 24 24 BAND =0.0 0.0 0.0  0.5 0.0 0.5  0.625  0.25  0.625, 0.375 0.375 0.75  0.0 0.0 0.0  0.5 0.5 0.5 BAND_POINTS = 101 FULL_FORCE_CONSTANTS = .TRUE. FORCE_CONSTANTS= WRITE #生成FORCE_CONSTANTS</code></pre><p>准备mesh.conf文件，如下所示：  </p><pre class=" language-lang-conf"><code class="language-lang-conf">ATOM_NAME = SiDIM = 2 2 2MP = 24 24 24</code></pre><p>获取声子谱后处理步骤</p><pre class=" language-lang-bash"><code class="language-lang-bash"> #直接在终端运行 #1. 提取动力学矩阵，进入disp-*的上一级文件夹 phonopy -f ./disp-*/vasprun.xml #会生成FORCE_SET #2. 计算声子谱并保存为pdf格式,同时生成FORCE_CONSTANTS phonopy -c POSCAR-unitcell band.conf -p -s #3. 将声子谱进一步输出为数据文件，用于其它软件画图。 #旧版本phonopy bandplot  --gnuplot> phonon.out #新版本phonopy phonopy-bandplot --gnuplot > phonon.out #phonon.out文件中首行是高对称点在x轴上的坐标</code></pre><p><img src="/img/Si_phonon.png" width = "60%" height = "60%" div align=center/></p>]]></content>
      
      
      <categories>
          
          <category> VASP计算笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VASP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>晶格常数计算</title>
      <link href="/2020/04/18/jing-ge-chang-shu-ce-shi/"/>
      <url>/2020/04/18/jing-ge-chang-shu-ce-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="晶格常数测试-Equation-of-state-method"><a href="#晶格常数测试-Equation-of-state-method" class="headerlink" title="晶格常数测试 (Equation of state method)"></a><strong>晶格常数测试 (Equation of state method)</strong></h3><p>必要输入文件</p><pre class=" language-lang-bash"><code class="language-lang-bash">run_a0.shPOTCARINCAR 和 KPOINTS可在run_a0.sh中直接设置，也可以单独给出。EOS.in</code></pre><p>三维立方晶格脚本示例：<br>Si</p><pre class=" language-lang-bash"><code class="language-lang-bash">#!/bin/shcat > INCAR.relax <<!Global Parameters  ISTART =  0            (Read existing wavefunction; if there)  ICHARG =  2            (Non-self-consistent: GGA/LDA band structures)  LREAL  = F             (Projection operators: automatic)  ENCUT  =  500          (Cut-off energy for plane wave basis set, in eV)   PREC   =  Accurate     (Precision level)    LWAVE  = .FALSE.       (Write WAVECAR or not)  LCHARG = .FALSE.       (Write CHGCAR or not)   ADDGRID= .TRUE.        (Increase grid; helps GGA convergence)   # LVTOT  = .TRUE.      (Write total electrostatic potential into LOCPOT or not)  # LVHAR  = .TRUE.      (Write ionic + Hartree electrostatic potential into LOCPOT or not)  # NELECT =             (No. of electrons: charged cells; be careful)  # LPLANE = .TRUE.      (Real space distribution; supercells)  # NPAR   = 4           (Max is no. nodes; don't set for hybrids)Electronic Relaxation  ISMEAR =  0            (Gaussian smearing; metals:1)  SIGMA  =  0.05         (Smearing value in eV; metals:0.2)  NELM   =  60           (Max electronic SCF steps)    NELMIN =  4            (Min electronic SCF steps)  EDIFF  =  1E-08        (SCF energy convergence; in eV)   GGA  =  PE             (PBEsol exchange-correlation)Ionic Relaxation  NELMIN =  6            (Min electronic SCF steps)   NSW    =  60           (Max electronic SCF steps)  IBRION =  2            (Algorithm: 0-MD; 1-Quasi-New; 2-CG)  ISIF   =  4            (Stress/relaxation: 2-Ions, 3-Shape/Ions/V, 4-Shape/Ions)  EDIFFG = -0.001        (Ionic convergence; eV/AA)  # ISYM =  2            (Symmetry: 0=none; 2=GGA; 3=hybrids)!cat > INCAR.static <<!Global Parameters  ISTART =  0            (Read existing wavefunction; if there)  ICHARG =  2            (Non-self-consistent: GGA/LDA band structures)  LREAL  = F             (Projection operators: automatic)  ENCUT  =  500          (Cut-off energy for plane wave basis set, in eV)   PREC   =  Accurate     (Precision level)    LWAVE  = .FALSE.       (Write WAVECAR or not)  LCHARG = .FALSE.       (Write CHGCAR or not)   ADDGRID= .TRUE.        (Increase grid; helps GGA convergence)   # LVTOT  = .TRUE.      (Write total electrostatic potential into LOCPOT or not)  # LVHAR  = .TRUE.      (Write ionic + Hartree electrostatic potential into LOCPOT or not)  # NELECT =             (No. of electrons: charged cells; be careful)  # LPLANE = .TRUE.      (Real space distribution; supercells)  # NPAR   = 4           (Max is no. nodes; don't set for hybrids)  GGA   = PEStatic Calculation  ISMEAR = -5            (tetrahedron method for DOS)   #LORBIT =  11          (PAW radii for projected DOS)  #NEDOS  =  2001        (DOSCAR points)   NELM   =  60           (Max electronic SCF steps)  EDIFF  =  1E-08        (SCF energy convergence; in eV)  EDIFFG = -0.001!cat > KPOINTS <<!A0M9  9  90  0  0!echo 'a0' 'volume' 'free_energy(eV)' >ev.outfor i in $(seq 5.00 0.05 5.90)docat > POSCAR <<!Si81.0000000000    $i                  0.0000000000        0.0000000000    0.0000000000        $i                  0.0000000000    0.0000000000        0.0000000000        $iSi8Direct    0.0000000000        0.0000000000        0.0000000000    0.2500000000        0.7500000000        0.7500000000    0.5000000000        0.0000000000        0.5000000000    0.0000000000        0.5000000000        0.5000000000    0.5000000000        0.5000000000        0.0000000000    0.7500000000        0.2500000000        0.7500000000    0.7500000000        0.7500000000        0.2500000000    0.2500000000        0.2500000000        0.2500000000!#优化计算cp INCAR.relax INCARecho "a=$i"; time mpirun -n 16 vasp_stdcp CONTCAR POSCARrm INCAR#静态计算cp INCAR.static INCARecho "a=$i"; time mpirun -n 16 vasp_stdV=$(grep "volume" OUTCAR | tail -1 | awk '{printf "%12.9f \n", $5 }')E=$(grep "TOTEN" OUTCAR | tail -1 | awk '{printf "%12.9f \n", $5 }')echo $i $V $E >> ev.outrm INCARdone</code></pre><p>提交脚本运算后得到ev.out。<br>利用vaspkit软件进行状态方程拟合。  </p><p>vaspkit需要准EOS.in文件，文件格式及说明如下：</p><pre class=" language-lang-in"><code class="language-lang-in"> cname               : name of crystal up to 256 characters natoms              : number of atoms in unit cell etype               : equation of state type (see below) vplt1, vplt2, nvplt : volume interval over which to plot energy, pressure etc.                       as well as the number of points in the plot nevpt               : number of energy-volume points to be inputted vpt(i) ept(i)       : energy-volume points (VASP units)Note that the input units are VASP default untis (i.e., A^3 and eV).The equations of state currently implemented are: 1. Universal EOS (Vinet P et al., J. Phys.: Condens. Matter 1, p1941 (1989)) 2. Murnaghan EOS (Murnaghan F D, Am. J. Math. 49, p235 (1937)) 3. Birch-Murnaghan 3rd-order EOS (Birch F, Phys. Rev. 71, p809 (1947)) 4. Birch-Murnaghan 4th-order EOS 5. Natural strain 3rd-order EOS (Poirier J-P and Tarantola A, Phys. Earth    Planet Int. 109, p1 (1998)) 6. Natural strain 4th-order EOS 7. Cubic polynomial in (V-V0)</code></pre><p>参考例子</p><p>Si</p><pre class=" language-lang-in"><code class="language-lang-in">Si83124.00 206 50019125.000000000 -39.404864520128.790000000 -40.307996560132.650000000 -41.074573950136.590000000 -41.714702140140.610000000 -42.237893500144.700000000 -42.653098650148.880000000 -42.968706720153.130000000 -43.192650580157.460000000 -43.332358630161.880000000 -43.394826990166.380000000 -43.386635660170.950000000 -43.313964240175.620000000 -43.182635890180.360000000 -42.998104870185.190000000 -42.765493980190.110000000 -42.489611560195.110000000 -42.174957610200.200000000 -41.825750520205.380000000 -41.445910010</code></pre><p>运行 <code>vaspkit -task 205</code><br>得到主要的输出文件 PARAM.out 如下：</p><pre class=" language-lang-out"><code class="language-lang-out">SiBirch-Murnaghan 3rd-order EOSBirch F, Phys. Rev. 71, p809 (1947)(Default VASP units: eV, Angstrom etc.)  V0 (A^3)          =            163.6206779 E0 (eV)           =           -43.39626828 B0                =           0.2982734905E-02 B0'               =            4.260966253 B0 (GPa)          =            87.75507591</code></pre><p>通过平衡体积可以得到晶格常数 $a_0=5.4694803016$<br>建议对得到的平衡晶格常数再优化一次。  </p><p>如果不想状态方程拟合，在较高精度下直接使用$ISIF = 3$ 的参数直接弛豫优化晶胞。<br>INCAR示例如下：  </p><pre class=" language-lang-bash"><code class="language-lang-bash">Global Parameters  ISTART =  0            (Read existing wavefunction; if there)  ICHARG =  2            (Non-self-consistent: GGA/LDA band structures)  LREAL  = F             (Projection operators: automatic)  ENCUT  =  500          (Cut-off energy for plane wave basis set, in eV)   PREC   =  Accurate     (Precision level)    LWAVE  = .FALSE.       (Write WAVECAR or not)  LCHARG = .FALSE.       (Write CHGCAR or not)   ADDGRID= .TRUE.        (Increase grid; helps GGA convergence)   # LVTOT  = .TRUE.      (Write total electrostatic potential into LOCPOT or not)  # LVHAR  = .TRUE.      (Write ionic + Hartree electrostatic potential into LOCPOT or not)  # NELECT =             (No. of electrons: charged cells; be careful)  # LPLANE = .TRUE.      (Real space distribution; supercells)  # NPAR   = 4           (Max is no. nodes; don't set for hybrids)Electronic Relaxation  ISMEAR =  0            (Gaussian smearing; metals:1)  SIGMA  =  0.05         (Smearing value in eV; metals:0.2)  NELM   =  60           (Max electronic SCF steps)    NELMIN =  4            (Min electronic SCF steps)  EDIFF  =  1E-08        (SCF energy convergence; in eV)   GGA  =  PE             (PBEsol exchange-correlation)Ionic Relaxation  NELMIN =  6            (Min electronic SCF steps)   NSW    =  60           (Max electronic SCF steps)  IBRION =  2            (Algorithm: 0-MD; 1-Quasi-New; 2-CG)  ISIF   =  3            (Stress/relaxation: 2-Ions, 3-Shape/Ions/V, 4-Shape/Ions)  EDIFFG = -0.001        (Ionic convergence; eV/AA)  # ISYM =  2            (Symmetry: 0=none; 2=GGA; 3=hybrids)</code></pre><p>注：在新版本的vaspkit中，给出了更多状态方程及其整个新的拟合流程，具体可参考程序实例。</p><p><br /></p><p>二维材料的六方晶格示例：<br>Tl2O</p><pre class=" language-lang-bash"><code class="language-lang-bash">#!/bin/shcat > INCAR.relax <<!Global Parameters  ISTART =  0            (Read existing wavefunction; if there)  ICHARG =  2            (Non-self-consistent: GGA/LDA band structures)  LREAL  = F             (Projection operators: automatic)  ENCUT  =  600          (Cut-off energy for plane wave basis set, in eV)   PREC   =  Accurate     (Precision level)    LWAVE  = .FALSE.        (Write WAVECAR or not)  LCHARG = .FALSE.        (Write CHGCAR or not)   ADDGRID= .TRUE.        (Increase grid; helps GGA convergence)   # LVTOT  = .TRUE.      (Write total electrostatic potential into LOCPOT or not)  # LVHAR  = .TRUE.      (Write ionic + Hartree electrostatic potential into LOCPOT or not)  # NELECT =             (No. of electrons: charged cells; be careful)  # LPLANE = .TRUE.      (Real space distribution; supercells)  # NPAR   = 4           (Max is no. nodes; don't set for hybrids)Electronic Relaxation  ISMEAR =  0            (Gaussian smearing; metals:1)  SIGMA  =  0.05         (Smearing value in eV; metals:0.2)  NELM   =  60           (Max electronic SCF steps)    NELMIN =  4            (Min electronic SCF steps)  EDIFF  =  1E-08        (SCF energy convergence; in eV)   GGA  =  PE             (PBEsol exchange-correlation)Ionic Relaxation  NELMIN =  6            (Min electronic SCF steps)   NSW    =  100          (Max electronic SCF steps)  IBRION =  2            (Algorithm: 0-MD; 1-Quasi-New; 2-CG)  ISIF   =  2            (Stress/relaxation: 2-Ions, 3-Shape/Ions/V, 4-Shape/Ions)  EDIFFG = -0.001         (Ionic convergence; eV/AA)  # ISYM =  2            (Symmetry: 0=none; 2=GGA; 3=hybrids)!cat > INCAR.static <<!Global Parameters  ISTART =  0            (Read existing wavefunction; if there)  ICHARG =  2            (Non-self-consistent: GGA/LDA band structures)  LREAL  = F             (Projection operators: automatic)  ENCUT  =  600          (Cut-off energy for plane wave basis set, in eV)   PREC   =  Accurate     (Precision level)    LWAVE  = .FALSE.        (Write WAVECAR or not)  LCHARG = .FALSE.        (Write CHGCAR or not)   ADDGRID= .TRUE.        (Increase grid; helps GGA convergence)   # LVTOT  = .TRUE.      (Write total electrostatic potential into LOCPOT or not)  # LVHAR  = .TRUE.      (Write ionic + Hartree electrostatic potential into LOCPOT or not)  # NELECT =             (No. of electrons: charged cells; be careful)  # LPLANE = .TRUE.      (Real space distribution; supercells)  # NPAR   = 4           (Max is no. nodes; don't set for hybrids)  GGA   = PEStatic Calculation  ISMEAR = -5           (tetrahedron method for DOS)   #SIGMA = 0.05  #LORBIT =  11           (PAW radii for projected DOS)  #NEDOS  =  2001         (DOSCAR points)   NELM   =  60           (Max electronic SCF steps)  EDIFF  =  1E-08        (SCF energy convergence; in eV)  EDIFFG = -0.001!cat > KPOINTS <<!A0G12 12 10  0  0!for i in $(seq 3.10 0.05 4.10)doj=`echo "$i * 0.5000000000"|bc`k=`echo "$i * 0.8660254038"|bc`cat > POSCAR <<!Tl2O1.0 $i               0.00000000000    0.00000000000-$j               $k               0.00000000000 0.00000000000    0.00000000000   25.00000000000Tl O2  1Direct  0.3333330099999969  0.6666670059999973  0.5606771909028483  0.6666669459999994  0.3333329709999973  0.4393227710971557  0.0000000000000000  0.0000000000000000  0.5000000000000000!cp INCAR.relax INCARecho "a=$j"; time mpirun -np 16 vasp_stdcp CONTCAR POSCARrm INCARcp INCAR.static INCARecho "a=$j"; time mpirun -np 16 vasp_stdV=$(grep "volume" OUTCAR | tail -1 | awk '{printf "%12.9f \n", $5 }')E=$(grep "TOTEN" OUTCAR | tail -1 | awk '{printf "%12.9f \n", $5 }')echo $i $V $E >> ev.datrm POSCARdone</code></pre><p>注：对于平面为矩形的二维材料，可以通过修改VASP源代码，直接使用ISIF=3对x、y方向优化。<br>详情见软件编译手册。</p>]]></content>
      
      
      <categories>
          
          <category> VASP计算笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VASP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>弹性常数计算</title>
      <link href="/2020/04/18/er-jie-dan-xing-chang-shu-ji-suan/"/>
      <url>/2020/04/18/er-jie-dan-xing-chang-shu-ji-suan/</url>
      
        <content type="html"><![CDATA[<h2 id="二阶弹性常数计算"><a href="#二阶弹性常数计算" class="headerlink" title="二阶弹性常数计算"></a><strong>二阶弹性常数计算</strong></h2><p>主要采用能量—应变方法</p><h3 id="AELAS软件计算"><a href="#AELAS软件计算" class="headerlink" title="AELAS软件计算"></a><strong>AELAS软件计算</strong></h3><p>必要的文件</p><pre class=" language-lang-bash"><code class="language-lang-bash">elas_strain.shelas_cal.shPOTCARINPOS 优化后的POSCAR。可在脚本设置或者单独给出KPOINTS 可在脚本设置或者单独给出incar_rlx 可在脚本设置或者单独给出incar_stc</code></pre><p>elas_strain.sh脚本参考如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">#!/bin/bashcat > INPOS <<!Si8                                     1.00000000000000       5.4684663969085214    0.0000000000000000    0.0000000000000000  0.0000000000000000    5.4684663969085214    0.0000000000000000  0.0000000000000000    0.0000000000000000    5.4684663969085214Si8Direct  0.0000000000000000  0.0000000000000000  0.0000000000000000  0.2500000000000000  0.7500000000000000  0.7500000000000000  0.5000000000000000  0.0000000000000000  0.5000000000000000  0.0000000000000000  0.5000000000000000  0.5000000000000000  0.5000000000000000  0.5000000000000000  0.0000000000000000  0.7500000000000000  0.2500000000000000  0.7500000000000000  0.7500000000000000  0.7500000000000000  0.2500000000000000  0.2500000000000000  0.2500000000000000  0.2500000000000000!AELAS -g #建立不同应变下的POSCAR_I_J。例如：POSCAR_01_001 #二维生成命令 AELAS -g2d#产生优化和静态计算的INCARcat > incar_rlx <<!ISTART=0ICHARG=2PREC=AccurateGGA = PEADDGRID =.TRUE.# Electronic relaxationENCUT=500EDIFF=1E-8ISMEAR=0SIGMA=0.05NELMIN=5# Ionic relaxationNSW=100EDIFFG=-1e-3ISIF=2IBRION=2POTIM=0.20# Other Tags#PSTRESS=#Write flagsLWAVE=.FALSE.LCHARG=.FALSE.!cat > incar_stc<<!ISTART=0ICHARG=2PREC=AccurateGGA = PEADDGRID =.TRUE.# Electronic relaxationENCUT=500EDIFF=1E-8EDIFFG=-0.001ISMEAR=-5#SIGMA = 0.05POTIM=0.20# Other Tags#PSTRESS=# Write flagsLWAVE=.FALSE.LCHARG=.FALSE.!cat > KPOINTS <<!A0M9  9  90  0  0!</code></pre><p>运行生成应变后的POSCAR及计算输入文件</p><p>elas_cal.sh脚本设置如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">for i in 01 02 03 #根据生成的数量设置dofor j in 001 002 003 004 005 006 007 008 009 010 011 012 013do#优化计算cp POS_"$i"_$j.vasp POSCARcp incar_rlx INCARecho "relax I= $i,J = $j"; time mpirun -np 16 vasp_std#静态计算cp CONTCAR POSCARrm INCARcp incar_stc INCARecho "static I= $i,J = $j"; time mpirun -np 16 vasp_stdcp OSZICAR OSZICAR_"$i"_$jrm INCARdonedone#计算弹性常数AELAS -d #二维产生 AELAS -d2d</code></pre><p>提交上述脚本计算，成功计算后生成ELADAT文件，形式如下：</p><pre class=" language-lang-txt"><code class="language-lang-txt"> Elastic tensor:   153.04   57.11   57.11    0.00    0.00    0.00   57.11  153.04   57.11    0.00    0.00    0.00   57.11   57.11  153.04    0.00    0.00    0.00    0.00    0.00    0.00   74.71    0.00    0.00    0.00    0.00    0.00    0.00   74.71    0.00    0.00    0.00    0.00    0.00    0.00   74.71 Compliance tensor:   0.008197 -0.002228 -0.002228  0.000000  0.000000  0.000000 -0.002228  0.008197 -0.002228  0.000000  0.000000  0.000000 -0.002228 -0.002228  0.008197  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000  0.013384  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000  0.013384  0.000000  0.000000  0.000000  0.000000  0.000000  0.000000  0.013384 Young's, shear and bulk moduli and Poisson ratio   Voigt approximate:   154.93   64.01   89.09   0.210   Reuss approximate:   149.17   61.09   89.09   0.221   Hill approximate :   152.05   62.55   89.09   0.216 Pugh ratio (G/K):   0.7021 Cauchy pressure (Pc=C12-C44):   -17.60 Elastic Anisotropy Index   Chung-Buessem Anisotropy Index (Ac=(Gv-Gr)/(Gv+Gr)):   0.0234   Universal Elastic Anisotropy Index (Au=5*Gv/Gr+Kv/Kr-6):   0.2396 Elastic Stability Conditions:  Stable</code></pre><p><br /></p><hr><h3 id="vaspkit软件"><a href="#vaspkit软件" class="headerlink" title="vaspkit软件"></a><strong>vaspkit软件</strong></h3><p>建议使用惯用晶胞，不要使用原始晶胞。可以借用上面软件的AELAS -d生成的RECELL文件。</p><p>版本1.0.0及以上</p><p>必要的文件</p><pre class=" language-lang-bash"><code class="language-lang-bash">elas_strain.shelas_cal.shPOTCARKPOINTS 可在脚本设置或者单独给出incar_rlx 可在脚本设置或者单独给出incar_stcVPKIT.in 可在脚本设置或者单独给出</code></pre><p>elas_strain.sh脚本参考如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">#!/bin/bashcat > VPKIT.in <<!1                                                              ! 1 for prep-rocessing, 2 for post-processing3D                                                             ! 2D for slab, 3D for bulk13                                                              ! number of strain-0.018 -0.015 -0.012 -0.009 -0.006 -0.003 0.000 0.003 0.006 0.009 0.012 0.015 0.018 ! magnitude of strain!cat > POSCAR <<!Si81.00000000000000  5.4684663969085214    0.0000000000000000    0.0000000000000000  0.0000000000000000    5.4684663969085214    0.0000000000000000  0.0000000000000000    0.0000000000000000    5.4684663969085214Si8Direct  0.0000000000000000  0.0000000000000000  0.0000000000000000  0.2500000000000000  0.7500000000000000  0.7500000000000000  0.5000000000000000  0.0000000000000000  0.5000000000000000  0.0000000000000000  0.5000000000000000  0.5000000000000000  0.5000000000000000  0.5000000000000000  0.0000000000000000  0.7500000000000000  0.2500000000000000  0.7500000000000000  0.7500000000000000  0.7500000000000000  0.2500000000000000  0.2500000000000000  0.2500000000000000  0.2500000000000000!#产生优化和静态计算的INCARcat > incar_rlx <<!ISTART=0ICHARG=2PREC=AccurateGGA = PEADDGRID =.TRUE.# Electronic relaxationENCUT=500EDIFF=1E-8ISMEAR=0SIGMA=0.05NELMIN=5# Ionic relaxationNSW=100EDIFFG=-1e-3ISIF=2IBRION=2POTIM=0.20# Other Tags#PSTRESS=#Write flagsLWAVE=.FALSE.LCHARG=.FALSE.KPAR=2!cat > incar_stc<<!ISTART=0ICHARG=2PREC=AccurateGGA = PEADDGRID =.TRUE.# Electronic relaxationENCUT=500EDIFF=1E-8EDIFFG=-0.001ISMEAR=-5#SIGMA = 0.05POTIM=0.20# Other Tags#PSTRESS=# Write flagsLWAVE=.FALSE.LCHARG=.FALSE.KPAR=2!cat > KPOINTS <<!A0M9  9  90  0  0!vaspkit -task 201 #建立不同应变下的POSCAR文件</code></pre><p>提交生成应变后的文件夹</p><p>elas_cal.sh脚本设置如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">#!/bin/bashroot_path=`pwd`for cij in `ls -F | grep /$`do  cd ${root_path}/$cij  for s in strain_*  do    cd ${root_path}/$cij/$s    echo `pwd`    #优化计算    cp ../../incar_rlx INCAR    time mpirun -np 16 vasp_std    rm INCAR    #静态计算    cp ../../incar_stc INCAR    time mpirun -np 16 vasp_std  donedonecd ${root_path}#计算弹性常数cat > VPKIT.in <<!2                                                              ! 1 for prep-rocessing, 2 for post-processing3D                                                             ! 2D for slab, 3D for bulk13                                                              ! number of strain-0.018 -0.015 -0.012 -0.009 -0.006 -0.003 0.000 0.003 0.006 0.009 0.012 0.015 0.018 ! magnitude of strain!vaspkit -task 201 > elastics.out</code></pre><p>成功计算后生成elastic.out文件，形式如下：</p><pre class=" language-lang-out"><code class="language-lang-out"> +---------------------------------------------------------------+ |             VASPKIT Version: 1.00 (16 Sep. 2019)              | |       A Pre- and Post-Processing Program for VASP Code        | |            Running VASPKIT Under Command-Line Mode            | +---------------------------------------------------------------+  -->> (01) Reading VPKIT.in File... +-------------------------- Warm Tips --------------------------+      See an example in vaspkit/examples/elastic/diamond_3D,      Require the fully-relaxed and standardized Convertional cell. +---------------------------------------------------------------+  -->> (02) Reading Structural Parameters from POSCAR File...  -->> (03) Calculating the fitting coefficients of energy vs strain.  -->> Current directory:  Fitting Precision               C44 Folder:  0.405E-09        C11_C12_I Folder:  0.244E-09       C11_C12_II Folder:  0.744E-08 +-------------------------- Summary ----------------------------+ Based on the Strain versus Energy method. Crystal Class: m-3m Space Group: Fd-3m Crystal System: Cubic system Including Point group classes: 23, 2/m-3, 432, -43m, 4/m-32/m There are 3 independent elastic constants    C11  C12  C12    0    0    0      C12  C11  C12    0    0    0      C12  C12  C11    0    0    0        0    0    0  C44    0    0        0    0    0    0  C44    0        0    0    0    0    0  C44   Stiffness Tensor C_ij (in GPa):    153.056     57.116     57.116      0.000      0.000      0.000     57.116    153.056     57.116      0.000      0.000      0.000     57.116     57.116    153.056      0.000      0.000      0.000      0.000      0.000      0.000     99.411      0.000      0.000      0.000      0.000      0.000      0.000     99.411      0.000      0.000      0.000      0.000      0.000      0.000     99.411 Compliance Tensor S_ij (in GPa^{-1}):   0.008196  -0.002227  -0.002227   0.000000   0.000000   0.000000  -0.002227   0.008196  -0.002227   0.000000   0.000000   0.000000  -0.002227  -0.002227   0.008196   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000   0.010059   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000   0.010059   0.000000   0.000000   0.000000   0.000000   0.000000   0.000000   0.010059 Elastic stability criteria as seen in PRB 90, 224104 (2014). Criteria (i) C11 - C12 > 0 meeted. Criteria (ii) C11 + 2C12 > 0 meeted. Criteria (iii) C44 > 0 meeted. This Structure is Mechanically Stable. Average mechanical properties for polycrystalline: +---------------------------------------------------------------+ |        Scheme             |   Voigt   |   Reuss   |    Hill   | +---------------------------------------------------------------+ |  Bulk modulus K (GPa)     |   89.096  |   89.096  |   89.096  | |  Shear modulus G (GPa)    |   78.835  |   69.569  |   74.202  | |  Young's modulus E (GPa)  |  182.637  |  165.605  |  174.236  | |  P-wave modulus (GPa)     |  194.209  |  181.855  |  188.032  | |  Poisson's ratio v        |    0.158  |    0.190  |    0.174  | |  Bulk/Shear ratio         |    1.130  |    1.281  |    1.201  | +---------------------------------------------------------------+ Pugh Ratio: 0.833 Cauchy Pressure (GPa):  -42.295 Universal Elastic Anisotropy: 0.666 ChungBuessem Anisotropy:    0.062 Isotropic Poissons Ratio: 0.174 Longitudinal wave velocity (in m/s):   9078.421 Transverse wave velocity (in m/s):   5702.983 Average wave velocity (in m/s):   6278.900 Debye temperature (in K):  683.685 References: [1] Voigt W, Lehrbuch der Kristallphysik (1928) [2] Reuss A, Z. Angew. Math. Mech. 9 4958 (1929) [3] Hill R, Proc. Phys. Soc. A 65 34954 (1952) [4] Debye temperature J. Phys. Chem. Solids 24, 909-917 (1963) [5] Elastic wave velocities calculated using Navier's equation +---------------------------------------------------------------+ +---------------------------------------------------------------+ | We Would Appreciate if You Cite in Your Research with VASPKIT.| | Ref: V. Wang, N. Xu, J.C. LIU, G. Tang, et al, VASPKIT: A Pre-| | and Post-Processing Program for VASP Code, arXiv:1908.08269.  | +---------------------------------------------------------------+</code></pre>]]></content>
      
      
      <categories>
          
          <category> VASP计算笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VASP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spglib安装教程</title>
      <link href="/2020/04/18/spglib-an-zhuang/"/>
      <url>/2020/04/18/spglib-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h2 id="Spglib安装教程"><a href="#Spglib安装教程" class="headerlink" title="Spglib安装教程"></a><strong>Spglib安装教程</strong></h2><h3 id="软件下载地址"><a href="#软件下载地址" class="headerlink" title="软件下载地址"></a>软件下载地址</h3><p>官网：<a href="https://atztogo.github.io/spglib/index.html" target="_blank" rel="noopener">https://atztogo.github.io/spglib/index.html</a><br>C版本下载：<a href="https://github.com/atztogo/spglib" target="_blank" rel="noopener">https://github.com/atztogo/spglib</a><br>python版本下载：<a href="https://pypi.org/project/spglib/" target="_blank" rel="noopener">https://pypi.org/project/spglib/</a></p><h2 id="安装编译"><a href="#安装编译" class="headerlink" title="安装编译"></a>安装编译</h2><p><strong>C版本安装编译</strong></p><p>Cmake方法</p><p>1 解压进入文件夹</p><pre class=" language-lang-bash"><code class="language-lang-bash">tar xvfz spglib-1.9.8.tar.gzcd spglib-1.9.8</code></pre><p>2 建立_build文件夹</p><pre class=" language-lang-bash"><code class="language-lang-bash">mkdir _build && _buildcmake -DCMAKE_INSTALL_PREFIX="" ..makemake DESTDIR=/some/where install#路径根据需要设置</code></pre><p>注：头文件spglib.h在安装路径include文件夹，如果include文件夹中没有spglib文件夹，建议手动建立一个并复制spglib.h文件到里面。这在后面的安装thirdorder软件时是有用的。</p><p><strong>Python库版本安装</strong></p><pre class=" language-lang-bash"><code class="language-lang-bash">#在线安装pip install spglib#手动安装tar -zxvf  spglib-1.14.1.post0.tar.gz spglibcd ./spglibpython setup.py install</code></pre><p><strong>Spglib的具体使用方法详见官网介绍，主要是作为库来调用</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算软件安装教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python环境安装教程</title>
      <link href="/2020/04/18/python-huan-jing/"/>
      <url>/2020/04/18/python-huan-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="Anaconda安装（python环境安装）"><a href="#Anaconda安装（python环境安装）" class="headerlink" title="Anaconda安装（python环境安装）"></a><strong>Anaconda安装（python环境安装）</strong></h2><p>注：Anaconda里python的第三方包十分丰富，包含了所有的常用包，省却了许多麻烦。本人安装的是python3.6版的Anaconda</p><h3 id="软件下载地址"><a href="#软件下载地址" class="headerlink" title="软件下载地址"></a>软件下载地址</h3><p>官网：<a href="https://www.anaconda.com/distribution/" target="_blank" rel="noopener">https://www.anaconda.com/distribution/</a></p><p>老版本下载网址（清华大学镜像）：<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a></p><h3 id="安装编译"><a href="#安装编译" class="headerlink" title="安装编译"></a>安装编译</h3><p>1 编译文件</p><pre class=" language-lang-bash"><code class="language-lang-bash">bash Anaconda3-5.2.0-Linux-x86_64.sh ##根据提示选择##注：其中会问你是否添加到环境变量，最好选择yes。source ~/.bashrc #直接配置环境变量##若选择novim ~/.bashrc #按i进入编辑模式###添加如下命令export PATH=/$dir/bin:$PATH  #$dir:Anaconda安装位置source ~/.bashrc</code></pre><p>2 测试</p><pre class=" language-lang-bash"><code class="language-lang-bash">python #终端运行，可查看python版本，按住ctrl+D可推出python模式which python #查看python位置</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算软件安装教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Intel编译器安装教程</title>
      <link href="/2020/04/18/intel-huan-jing/"/>
      <url>/2020/04/18/intel-huan-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="Intel-Parallel-Studio-XE-2019"><a href="#Intel-Parallel-Studio-XE-2019" class="headerlink" title="Intel Parallel Studio XE 2019"></a><strong>Intel Parallel Studio XE 2019</strong></h2><p>注：Intel编译器个人认为安装方便，库很齐全，MKL数学库很强大，对于安装其它软件来说十分便利。另外Intel编译器对于Intel处理器感觉运算速度会提升。</p><p><strong>后续所有软件都将基于Intel编译器安装，其它编译器安装方式请自行搜索。</strong></p><h3 id="软件下载地址"><a href="#软件下载地址" class="headerlink" title="软件下载地址"></a>软件下载地址</h3><p>该软件为商业版，学生可通过学生邮箱再Intel官网上申请教育版。</p><h3 id="安装编译"><a href="#安装编译" class="headerlink" title="安装编译"></a>安装编译</h3><p>1 解压进入文件编译</p><pre class=" language-lang-bash"><code class="language-lang-bash">sudo su #进入root模式bash install_GUI.sh #图形界面安装bash install.sh #命令界面##根据需要选择安装的库，不清楚可默认。</code></pre><p>2 配置环境变量</p><pre class=" language-lang-bash"><code class="language-lang-bash">vim ~/.bashrc #打开配置文件，按i进入编辑模式source /$dir/parallel_studio_xe_2019.1.053/psxevars.sh intel64 #添加该命令后保存退出。该命令可自动加载ifort icc MKL库等到环境变量。$dir:intel安装路径##注：Intel一般默认安装在/opt/intel里source ~/.bashrc #修改环境变量</code></pre><p>3 测试</p><pre class=" language-lang-bash"><code class="language-lang-bash">#检测是否有ifort和icc添加到环境变量which ifortwhich icc</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算软件安装教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BoltzTraP-1.2.5安装教程</title>
      <link href="/2020/04/18/boltztrap1-2-5-an-zhuang/"/>
      <url>/2020/04/18/boltztrap1-2-5-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h2 id="BoltzTraP-1-2-5安装教程"><a href="#BoltzTraP-1-2-5安装教程" class="headerlink" title="BoltzTraP-1.2.5安装教程"></a><strong>BoltzTraP-1.2.5安装教程</strong></h2><h3 id="软件下载地址"><a href="#软件下载地址" class="headerlink" title="软件下载地址"></a>软件下载地址</h3><p>小木虫网站上应该有。</p><h3 id="安装编译"><a href="#安装编译" class="headerlink" title="安装编译"></a>安装编译</h3><p>1 解压文件并进入src文件夹</p><pre class=" language-lang-bash"><code class="language-lang-bash">tar -zxvf BoltzTraP.tar.gzcd boltztrap-1.2.5/src</code></pre><p>2 修改Makefile文件</p><p>修改后的Makefile如下：</p><pre class=" language-lang-makefile"><code class="language-lang-makefile">SHELL = /bin/sh# gfortran#FC = gfortran#FC = gfortran-mp-4.5#FOPT  = -g -march=native -funroll-loops -O3 -ffast-math -fgcse-lm -fgcse-sm -ffast-math -ftree-vectorize -fexternal-blas#FOPT += -g -p -pg -Wall -fbounds-check -finit-integer=-666 -finit-real=nan#LDFLAGS =LIBS = -llapack -lblas# ifortFC = ifortFOPT = -FR -mp1 -w -prec_div -pc80 -pad -ip -DINTEL_VML#LDFLAGS = -L/opt/intel/mkl/10.0.1.014/lib/32/ -Vaxlib -static-libcxa -pthread#LIBS = -lmkl_lapack -lmkl_ia32 -lguide# ifort bis: other mkl options#LDFLAGS = $(FOPT) -L/opt/intel/mkl/10.0.1.014/lib/32 -pthread -i-static#LIBS = -lmkl_lapack -lmkl -lguideLDFLAGS = $(FOPT) -L/$MKLROOT/lib/intel64 -pthread -i-staticLIBS = -lmkl_lapack -lmkl_intel_lp64 -lmkl_sequential -lmkl_core -lguide# genericLINKER  =       $(FC)LFLAGS  = -g #-pgFGEN = DESTDIR = .EXECNAME = BoltzTraP###############################################################################FFLAGS = $(FGEN) $(FOPT)EXEC = $(DESTDIR)/$(EXECNAME)#..............................................................................##  Object files common to both REAL and COMPLEX type subroutines#OBJS = gmlib2.o reallocate.o \     m_bandstructure.o m_input.o m_fermimod.o \     m_interfaces.o \     latgen2.o generic_field.o gtfnam.o gen_lattpoints.o \     BoltzTraP.o crystal_band.o wien_band.o phon_band.o generic_band.o pw_interface.o \     add_inv.o bandana.o stern1.o kdelta.o fite4.o sortag.o gplbands.o \     dos.o ifflim.o setfft.o c3fft.o boseintegrals.o fermiintegrals.o bands.o kcomp.o \     bz.o fermisurface.o setfft2.o write_dx_fs.o write_dx_bz.o write_cube_fs.o \     dos_histogram.o dos_tetra.o noculc.o dosvv.o readvv.o \     phonondrag.o#OBJS =    \#        reallocate.o defs.o modules.o broad.o add_inv.o \#        c3fft.o gtfnam.o ifflim.o mknam.o read_energy.o \#        transport.o stern.o kdelta.o gen_lattpoints.o fite4.o setfft.o \#        starfkt2.o dos.o $(EXEC): $(OBJS)    $(LINKER) $(LFLAGS) -o $(EXEC) $(OBJS) $(LDFLAGS) $(LIBS) $(LFLAGS)clean:    rm -f *.o *.mod *.pc *.pcl *~.SUFFIXES: .F90 .o .F90.o:    $(FC) $(FFLAGS) -c $<</code></pre><p>修改完成后编译</p><pre class=" language-lang-bash"><code class="language-lang-bash">make</code></pre><p>3 添加到环境变量</p><pre class=" language-lang-bash"><code class="language-lang-bash">vim ~/.bashrc export PATH=/$dir/src:$PATH #$dir：boltztrap-1.2.5安装位置source ~/.bashrc</code></pre><h3 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a>运行命令</h3><pre class=" language-lang-bash"><code class="language-lang-bash">x_trans BoltzTraP</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算软件安装教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VASP5.4.4安装教程</title>
      <link href="/2020/04/18/vasp-an-zhuang/"/>
      <url>/2020/04/18/vasp-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h2 id="VASP-5-4-4-CPU-安装教程"><a href="#VASP-5-4-4-CPU-安装教程" class="headerlink" title="VASP-5.4.4(CPU)安装教程"></a><strong>VASP-5.4.4(CPU)安装教程</strong></h2><h3 id="软件下载地址"><a href="#软件下载地址" class="headerlink" title="软件下载地址"></a>软件下载地址</h3><p>VASP软件需要付费，请自行下载。</p><h3 id="安装编译"><a href="#安装编译" class="headerlink" title="安装编译"></a>安装编译</h3><p>1 拷贝makefile.include到vasp文件夹</p><pre class=" language-lang-sh"><code class="language-lang-sh">tar -zxvf vasp.tar.gzcd vasp.5.4.4 #根据实际文件名字修改cp ./arch/makefile.include.linux_intel makefile.include #arch里面有很多例子根据需要修改</code></pre><p>2 修改makefile.include</p><pre class=" language-lang-sh"><code class="language-lang-sh">vim makefile.include##如果是Intel编译器，可以直接默认设置</code></pre><p>makefile.include基本如下所示：</p><pre class=" language-lang-makefile"><code class="language-lang-makefile"># Precompiler optionsCPP_OPTIONS= -DHOST=\"LinuxIFC\"\             -DMPI -DMPI_BLOCK=8000 \             -Duse_collective \             -DscaLAPACK \             -DCACHE_SIZE=8000 \             -Davoidalloc \             -Duse_bse_te \             -Dtbdyn \             -Duse_shmemCPP        = fpp -f_com=no -free -w0  $*$(FUFFIX) $*$(SUFFIX) $(CPP_OPTIONS)FC         = mpiifortFCL        = mpiifort -mkl=sequential -lstdc++FREE       = -free -names lowercaseFFLAGS     = -assume byterecl -wOFLAG      = -O2 -xhostOFLAG_IN   = $(OFLAG)DEBUG      = -O0MKL_PATH   = $(MKLROOT)/lib/intel64BLAS       =LAPACK     =BLACS      = -lmkl_blacs_intelmpi_lp64SCALAPACK  = $(MKL_PATH)/libmkl_scalapack_lp64.a $(BLACS)OBJECTS    = fftmpiw.o fftmpi_map.o fft3dlib.o fftw3d.oINCS       =-I$(MKLROOT)/include/fftwLLIBS      = $(SCALAPACK) $(LAPACK) $(BLAS)OBJECTS_O1 += fftw3d.o fftmpi.o fftmpiw.oOBJECTS_O2 += fft3dlib.o# For what used to be vasp.5.libCPP_LIB    = $(CPP)FC_LIB     = $(FC)CC_LIB     = iccCFLAGS_LIB = -OFFLAGS_LIB = -O1FREE_LIB   = $(FREE)OBJECTS_LIB= linpack_double.o getshmem.o# For the parser libraryCXX_PARS   = icpcLIBS       += parserLLIBS      += -Lparser -lparser -lstdc++# Normally no need to change thisSRCDIR     = ../../srcBINDIR     = ../../bin#================================================# GPU StuffCPP_GPU    = -DCUDA_GPU -DRPROMU_CPROJ_OVERLAP -DUSE_PINNED_MEMORY -DCUFFT_MIN=28 -UscaLAPACKOBJECTS_GPU = fftmpiw.o fftmpi_map.o fft3dlib.o fftw3d_gpu.o fftmpiw_gpu.oCC         = iccCXX        = icpcCFLAGS     = -fPIC -DADD_ -Wall -openmp -DMAGMA_WITH_MKL -DMAGMA_SETAFFINITY -DGPUSHMEM=300 -DHAVE_CUBLASCUDA_ROOT  ?= /usr/local/cuda/NVCC       := $(CUDA_ROOT)/bin/nvcc -ccbin=iccCUDA_LIB   := -L$(CUDA_ROOT)/lib64 -lnvToolsExt -lcudart -lcuda -lcufft -lcublasGENCODE_ARCH    := -gencode=arch=compute_30,code=\"sm_30,compute_30\" \                   -gencode=arch=compute_35,code=\"sm_35,compute_35\" \                   -gencode=arch=compute_60,code=\"sm_60,compute_60\"MPI_INC    = $(I_MPI_ROOT)/include64/</code></pre><p>3 编译</p><pre class=" language-lang-bash"><code class="language-lang-bash">make all##编译成功会在bin文件夹里生成vasp_std, vasp_gam, vasp_ncl。##只生成其中一个命令，例如vasp_stdmake vasp_std #绝大多数vasp计算只需用到vasp_std</code></pre><p>4 配置环境变量</p><pre class=" language-lang-bash"><code class="language-lang-bash">vim ~/.bashrc#添加路径export PATH=/$dir/bin:$PATH #$dir：vasp安装地址。source ~/.bashrcwhich vasp_std #检查是否配置成功</code></pre><h3 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a>运行命令</h3><p>```bash<br>mpirun -np 8 vasp_std &gt; vasp.log #实时输出结果在vasp.log中</p>]]></content>
      
      
      <categories>
          
          <category> 计算软件安装教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thirdorder安装教程</title>
      <link href="/2020/04/18/thirdorder-an-zhuang/"/>
      <url>/2020/04/18/thirdorder-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h2 id="thirdorder安装教程"><a href="#thirdorder安装教程" class="headerlink" title="thirdorder安装教程"></a><strong>thirdorder安装教程</strong></h2><p>产生用于三阶力常数计算的文件</p><h3 id="软件下载地址"><a href="#软件下载地址" class="headerlink" title="软件下载地址"></a>软件下载地址</h3><p>官网：<a href="http://www.shengbte.org/downloads" target="_blank" rel="noopener">http://www.shengbte.org/downloads</a></p><h3 id="安装编译"><a href="#安装编译" class="headerlink" title="安装编译"></a>安装编译</h3><p>1 解压进入文件夹</p><pre class=" language-lang-bash"><code class="language-lang-bash">tar -jxvf thirdorder-v1.1.1-8526f47.tar.bz2cd thirdorder</code></pre><p>2 修改setup.py 加入spglib的库路径</p><p>修改后如下</p><p>注：如果include文件夹里没有spglib文件夹，手动建一个并把spglib.h拷贝进去就行。</p><pre class=" language-lang-python"><code class="language-lang-python">#!/usr/bin/env python# -*- encoding: utf-8 -*-import numpyfrom distutils.core import setupfrom distutils.extension import Extension# Add the location of the "spglib/spglib.h" to this list if necessary.# Example: INCLUDE_DIRS=["/home/user/local/include"]INCLUDE_DIRS = ["/home/wh/software/spglib-master/usr/local/include"]# Add the location of the spglib shared library to this list if necessary.# Example: LIBRARY_DIRS=["/home/user/local/lib"]LIBRARY_DIRS = ["/home/wh/software/spglib-master/usr/local/lib"]# Set USE_CYTHON to True if you want include the cythonization in your build# process.USE_CYTHON = Falseext = ".pyx" if USE_CYTHON else ".c"extensions = [    Extension(        "thirdorder_core", ["thirdorder_core" + ext],        include_dirs=[numpy.get_include()] + INCLUDE_DIRS,        library_dirs=LIBRARY_DIRS,        runtime_library_dirs=LIBRARY_DIRS,        libraries=["symspg"])]if USE_CYTHON:    from Cython.Build import cythonize    extensions = cythonize(extensions)setup(name="thirdorder", ext_modules=extensions)</code></pre><p>修改完成后编译安装</p><pre class=" language-lang-bash"><code class="language-lang-bash">python setup.py install</code></pre><h3 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a>运行命令</h3><p>以VASP程序的POSCAR为例</p><p>1 拷贝源代码中的 thirdorder_common.py 和 thirdorder_vasp.py 两个文件到POSCAR目录下</p><p>2 运行命令</p><pre class=" language-lang-bash"><code class="language-lang-bash">thirdorder_vasp.py sow|reap na nb nc cutoff[nm/-integer]#examplethirdorder_vasp.py sow|reap 6 6 6 0.5 #0.5nm的截断半径thirdorder_vasp.py sow|reap 6 6 6 -3 #第三最近邻截断</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算软件安装教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Publications</title>
      <link href="/2020/04/17/publications/"/>
      <url>/2020/04/17/publications/</url>
      
        <content type="html"><![CDATA[<ol><li><p><a href="https://doi.org/10.1016/j.ssc.2019.02.004" target="_blank" rel="noopener">Wang Hao, Zhou Yu, Zeng Zhao-Yi, Cheng Yan, Chen Qi-Feng, First-principles study of elastic, thermal and optical properties of a metal-shrouded two-dimensional semiconductor Tl2O, <strong>Solid State Commun.</strong> 293 (2019) 40.</a></p></li><li><p><a href="https://www.sciencedirect.com/science/article/pii/S0022311519303472" target="_blank" rel="noopener">Wang Hao, Lan Jun-Qing, Hu Cui-E, Chen Xiang-Rong, Geng Hua-Yun, Electronic structure, elastic and thermal transport properties of thorium monocarbide based on first-principles study, <strong>J. Nucl. Mater.</strong> 524 (2019) 141.</a></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ShengBTE安装教程</title>
      <link href="/2020/04/17/shengbte-an-zhuang/"/>
      <url>/2020/04/17/shengbte-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h2 id="ShengBTE安装教程"><a href="#ShengBTE安装教程" class="headerlink" title="ShengBTE安装教程"></a><strong>ShengBTE安装教程</strong></h2><h3 id="软件下载地址"><a href="#软件下载地址" class="headerlink" title="软件下载地址"></a>软件下载地址</h3><p>官网：<a href="http://www.shengbte.org/downloads" target="_blank" rel="noopener">http://www.shengbte.org/downloads</a></p><h3 id="安装编译"><a href="#安装编译" class="headerlink" title="安装编译"></a>安装编译</h3><p>1 解压进入文件夹</p><pre class=" language-lang-bash"><code class="language-lang-bash">tar -jxvf ShengBTE-v1.1.1-8a63749.tar.bz2cd ShengBTE/src</code></pre><p>2 修改arch.make文件</p><p>修改后文件如下</p><pre class=" language-lang-makefile"><code class="language-lang-makefile">export FFLAGS=-traceback -debug -O2 -static_intelexport LDFLAGS=/home/wh/software/spglib-master/usr/local/lib/libsymspg.aexport MPIFC=mpiifortMKL=$(MKLROOT)/lib/intel64/libmkl_lapack95_lp64.a -Wl,--start-group    \$(MKLROOT)/lib/intel64/libmkl_intel_lp64.a                \$(MKLROOT)/lib/intel64/libmkl_sequential.a                \$(MKLROOT)/lib/intel64/libmkl_core.a -Wl,--end-group -lpthread -lmexport LAPACK=$(MKL)export LIBS=$(LAPACK)</code></pre><p>修改完成后</p><pre class=" language-lang-bash"><code class="language-lang-bash">make</code></pre><p>3 添加环境变量</p><pre class=" language-lang-bash"><code class="language-lang-bash">vim ~/.bashrc#加入如下命令export PATH=/$dir/src:$PATH #$dir：ShengBTE文件夹路径#保存退出source ~/.bashrc</code></pre><h3 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a>运行命令</h3><pre class=" language-lang-bash"><code class="language-lang-bash">mpirun -np 16 ShengBTE 2>BTE.err >BTE.out</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算软件安装教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
